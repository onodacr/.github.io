<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>介入記録マップ（修正版）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.magnifyingglass@1.0.0/leaflet.magnifyingglass.css" />

    <style>
        body { font-family: sans-serif; margin: 0; padding: 0; }
        #map { height: 75vh; }
        #controls {
            padding: 10px;
            background: #f8f8f8;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        button, input, select {
            padding: 8px 16px;
            font-size: 16px;
            border-radius: 4px; 
            border: 1px solid #ccc; 
            cursor: pointer; 
        }
        button:hover {
            background-color: #e9e9e9;
        }
        button:active, button.active { 
            background-color: #d0d0d0;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        input[type="text"], select {
            flex: 1;
            min-width: 150px;
            cursor: auto; 
        }
        #status { width: 100%; }
        #offlineStatus { width: 100%; color: orange; font-size: 0.9em; margin-top: 5px;}


        input#projectName.warning, input#tripNumber.warning {
            background-color: yellow;
            color: red;
            border: 1px solid red;
        }
        input#projectName.warning::placeholder, input#tripNumber.warning::placeholder {
            color: red;
            opacity: 0.7;
        }

        .direction-button.selected {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }
        #toggleLabelsButton.labels-hidden {
            background-color: #ffc107;
            border-color: #ffab00;
        }
        .control-button-small {
            padding: 6px 12px !important;
            font-size: 14px !important;
        }
        #bus-stop-buttons-container {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            width: 100%;
            padding: 5px 0;
            justify-content: flex-start;
        }
        .busstop-main-button {
            padding: 4px 8px;
            font-size: 14px;
        }
        .busstop-sub-buttons {
            display: none; /* 初期状態は非表示 */
            margin-top: 4px;
            padding: 4px;
            background: #f0f0f0;
            border-radius: 4px;
            position: absolute;
            z-index: 1001;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .busstop-sub-buttons button {
            font-size: 0.8em;
            padding: 3px 6px;
            display: block;
            width: 100%;
            margin: 2px 0;
        }
        
        body.mobile-mode #controls > * {
            display: none;
        }
        body.mobile-mode #projectName,
        body.mobile-mode #tripNumber,
        body.mobile-mode button[data-mobile],
        body.mobile-mode #geoFileInput,
        body.mobile-mode #drive-files
         {
            display: block !important;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        body.mobile-mode #map {
            height: 55vh;
        }
        body.mobile-mode #controls input[type="text"],
        body.mobile-mode #controls select,
        body.mobile-mode #controls button[data-mobile],
        body.mobile-mode #controls button#showDriveButton
        {
            font-size: 24px;
            padding: 20px;
            margin-bottom: 20px;
        }
        body.mobile-mode #controls button[data-mobile].gps-button {
            font-size: 32px;
            padding: 30px;
        }
        body.mobile-mode input#geoFileInput {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 20px;
            color: transparent;
            font-size: 1px;
            padding: 0;
        }
        body.mobile-mode input#geoFileInput::file-selector-button {
            font-size: 24px;
            padding: 20px;
            width: 100%;
            border: 1px solid #888;
            background: #f2f2f2;
            color: #333;
            border-radius: 4px;
            cursor: pointer;
            margin: 0;
        }

        body.mobile-mode input#geoFileInput::file-selector-button:active {
            background: #e0e0e0;
        }
        #modeSelector {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(255,255,255,0.95);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #modeSelector button {
            font-size: 20px;
            margin: 10px;
            padding: 12px 24px;
        }
        .multi-select button {
            margin: 4px;
            padding: 6px 12px;
            border: 1px solid #888;
            background: #f2f2f2;
            border-radius: 4px;
            cursor: pointer;
        }
        .multi-select button.selected { 
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }
        div[data-pos] {
    background: #eee;
    cursor: pointer;
    border-radius: 4px;
    width: 100%;
    min-height: 28px; /* ★高さを42pxから32pxに縮めました */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    box-sizing: border-box;
    padding: 4px; /* ★余白も少し調整 */
    line-height: 1.2;
    word-break: break-word;
    font-size: 13px; /* ★文字サイズを小さくする指定を追加 */
}
        div[data-pos].selected {
            background: #007bff;
            color: white;
        }

        #self-vehicle-cell {
            background: #ccc !important;
            font-weight: bold;
            border-radius: 4px;
            width: 100%;
            min-height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
            padding: 5px;
            line-height: 1.2;
            word-break: break-word;
        }

        #modal-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        #modal-header-controls h3 {
             margin: 0 10px;
        }
        #modal-header-controls .header-buttons-left button,
        #modal-header-controls .header-buttons-right button {
            margin: 0 5px;
        }
        /* Generic Modal Style */
        .modal-overlay {
            display:none; 
            position:fixed; 
            top:0; left:0; 
            width:100%; height:100%; 
            background:rgba(0,0,0,0.6); 
            z-index:9998; 
            justify-content:center; 
            align-items:center;
        }
        .modal-content-box {
            background:#fff;
            padding: 10px 20px 20px 20px;
            border-radius:8px;
            text-align:left;
            box-sizing: border-box;
            flex-shrink: 0;
            width:95%;
            overflow-y: auto;
            max-height:90vh;
            display: flex;
            flex-direction: column;
        }
        #customModal .modal-content-box, 
        #nonInterventionModal .modal-content-box,
        #minorReasonModal .modal-content-box,
        #busStopRecordModal .modal-content-box,
        #areaInfoModal .modal-content-box,
        #favoriteDetailModal .modal-content-box {
            max-width:600px;
        }
        
        body:not(.mobile-mode) .modal-content-box {
            max-width: 80vw;
            min-width: 700px;
        }
         body:not(.mobile-mode) #minorReasonModal .modal-content-box {
            min-width: 500px;
            max-width: 60vw;
         }
         body:not(.mobile-mode) #favoriteDetailModal .modal-content-box {
             min-width: 500px;
             max-width: 60vw;
         }
        body:not(.mobile-mode) #customModal .modal-content-box {
            min-width: 1200px;
        }


        body:not(.mobile-mode) .modal-field {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 10px;
        }

        body:not(.mobile-mode) .modal-field > p {
             flex: 0 0 120px;
             margin-top: 0.5em;
             font-weight: bold;
        }

        body:not(.mobile-mode) .modal-field > div:not(.major-reason-input-group) {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        /* Layout fix for Bus Stop Modal weather buttons */
        body:not(.mobile-mode) #busStopRecordModal .modal-field > div {
             flex-direction: row;
             flex-wrap: wrap;
             align-items: center;
        }


        body:not(.mobile-mode) .modal-field-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }

        body:not(.mobile-mode) .modal-field-controls .multi-select {
            order: 1;
            flex-basis: 100%;
        }
        body:not(.mobile-mode) .modal-field-controls .modal-select-group {
            order: 2;
        }
        body:not(.mobile-mode) .modal-field-controls .modal-input-group {
            order: 2;
        }

        .speech-bubble-tooltip {
            background: transparent !important;
            border: none !important;
            color: #333 !important; 
            text-shadow: 
                -1px -1px 0 #fff,  
                 1px -1px 0 #fff,
                -1px  1px 0 #fff,
                 1px  1px 0 #fff;
            font-weight: bold;
            font-size: 12px !important;
            padding: 2px 5px !important;
            box-shadow: none !important;
        }
        .speech-bubble-tooltip::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -10px;
            margin-top: -8px; 
            border-width: 8px;
            border-style: solid;
            border-color: transparent;
            border-right-color: #3388ff;
        }

        .modal-select-group, .modal-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #minorReasonModalContent .modal-input-group {
            width: 100%;
        }

        .modal-select-group > *, .modal-input-group > * {
            flex-shrink: 0;
        }

        body.mobile-mode .modal-field,
        body.mobile-mode .modal-field-controls,
        body.mobile-mode .modal-select-group,
        body.mobile-mode .modal-input-group {
            display: block;
            gap: 0;
            margin-bottom: 10px;
        }
         body.mobile-mode .modal-field > p {
             flex: auto;
             margin-top: 0;
             font-weight: bold;
         }
        .non-intervention-field {
            margin-bottom: 15px;
        }
        .non-intervention-field p {
            margin-top: 0;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .non-intervention-field textarea,
        .non-intervention-field input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            padding: 8px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .non-intervention-field label {
            margin-right: 15px;
            display: inline-block;
        }
        .signal-detection-options {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .signal-detection-options input[type="text"] {
            flex-grow: 1;
            min-width: 150px;
        }
        .modal-footer {
             text-align:right;
             margin-top: auto; /* Push footer to the bottom */
             padding-top: 20px;
             display: flex; 
             justify-content: flex-end; 
             gap: 10px; 
        }
        .modal-footer button, #modal-header-controls button {
            padding: 8px 20px;
            border: 1px solid #adadad;
            background-color: #f0f0f0;
        }
        .modal-footer button:hover, #modal-header-controls button:hover {
            background-color: #e0e0e0;
        }
        .modal-footer button.ok-button, #modal-header-controls .header-buttons-left button:first-child { 
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .modal-footer button.ok-button:hover, #modal-header-controls .header-buttons-left button:first-child:hover {
            background-color: #0056b3;
            border-color: #0056b3;
        }
        .modal-footer button.cancel-button, 
        #modal-header-controls .header-buttons-left button:last-child,
        #modal-header-controls .header-buttons-right button,
        #minorReasonModalHeader button 
         { 
            background-color: #6c757d;
            color: white;
            border-color: #6c757d;
        }
        .modal-footer button.cancel-button:hover, 
        #modal-header-controls .header-buttons-left button:last-child:hover,
        #modal-header-controls .header-buttons-right button:hover,
        #minorReasonModal .modal-footer button:last-child:hover,
        #minorReasonModalHeader button:hover {
            background-color: #545b62;
            border-color: #545b62;
        }
        button.processing { 
            background-color: #ffc107 !important; 
            color: #212529 !important;
            cursor: not-allowed !important;
            border-color: #ffc107 !important;
        }
        .modal-footer .favorite-buttons-container { 
            margin-right: auto; 
            display: flex;
            gap: 5px;
        }
        .modal-footer .favorite-buttons-container button {
            background-color: #ffc107; 
            color: #212529;
            border-color: #ffab00;
        }
         .modal-footer .favorite-buttons-container button:hover {
            background-color: #e0a800;
        }


        .leaflet-control-custom button {
            background-color: white;
            border: 2px solid #ccc;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
        }
        .leaflet-control-custom button:hover {
            background-color: #f4f4f4;
        }
        .street-parking-avoidance-sub-buttons {
            display: none;
            margin-top: 5px;
        }
        .street-parking-avoidance-sub-buttons button.cancel {
            background-color: #dc3545;
            color: white;
            border: none;
        }
        #selectedReasonDisplay {
            margin-top: 10px;
            padding: 8px;
            border: 1px solid #e0e0e0;
            background-color: #f9f9f9;
            border-radius: 4px;
            min-height: 20px;
            font-size: 0.9em;
            color: #333;
        }
        .major-reason-input-group {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            width: 100%;
        }
        .major-reason-input-group input {
            flex-grow: 1;
        }
        #minorReasonModal .modal-content-box .modal-field {
            display: block;
            margin-bottom: 10px;
        }
        #minorReasonModal .modal-content-box .modal-field p {
            margin-bottom: 5px;
        }
        /* ★★★ 変更箇所 START ★★★ */
        /* ボタンのコンテナを横並びに設定 */
        #minorReasonButtonsContainer {
            display: flex;
            flex-direction: row; /* ボタンを横に並べるための設定 */
            flex-wrap: wrap;
            gap: 5px;
        }
        /* ★★★ 変更箇所 END ★★★ */
        #minorReasonModal .modal-content-box .modal-input-group {
            display: flex;
            gap: 5px;
        }
         #minorReasonModal .modal-content-box .modal-input-group input {
            flex-grow: 1;
        }

        #minorReasonModal .modal-content-box > div:nth-of-type(3) {
            margin-bottom: 20px;
            text-align: left;
        }
                
        #reason-major-buttons button.selected-major {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }
        /* START: Intervention reason button size adjustment */
        #reason-major-buttons button {
            padding: 4px 10px;
            font-size: 14px;
        }
        /* END: Intervention reason button size adjustment */

        /* Favorite Shortcut Button Styles */
        .leaflet-control-favorites {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .leaflet-control-favorites button {
            background-color: #e7e7e7;
            border: 1px solid #ccc;
            color: #333;
            padding: 5px 8px;
            margin: 0;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .leaflet-control-favorites button:hover {
            background-color: #d4d4d4;
        }
        .leaflet-control-favorites button.favorite-active,
        .leaflet-control-favorites button.delete-target { 
            background-color: #ffc107; 
            color: #212529;
            border-color: #ffab00;
        }
        button#deleteFavoriteButton.delete-mode-active {
            background-color: #dc3545; 
            color: white;
        }

        a.leaflet-control-magnifier-toggle {
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: none !important;
        }
        a.leaflet-control-magnifier-toggle.active {
            background-color: #ddd;
        }
        
        .style-control { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .style-control label { font-weight: bold; flex-basis: 150px; }
        .style-control input[type="color"] { padding: 0; border: 1px solid #ccc; width: 100px; height: 30px; cursor: pointer; }
        .style-control input[type="range"] { flex-grow: 1; margin-left: 10px; }
        
        .direction-button.warning {
            border: 2px solid red !important;
        }

        /* 手動設置アイコン関連のスタイル */
        .placemark-icon {
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            border: 2px solid #333;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            cursor: move;
        }
        .leaflet-control-placemarks {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .leaflet-control-placemarks .placemark-button {
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .leaflet-control-placemarks .placemark-button:hover {
            background-color: #f4f4f4;
        }
        .leaflet-control-placemarks .placemark-button.active {
            background-color: #007bff;
            border-color: #0056b3;
        }
        .leaflet-control-placemarks .placemark-button.active svg {
            fill: white;
            stroke: white;
        }
        .leaflet-control-placemarks .placemark-button svg {
            width: 20px;
            height: 20px;
            fill: #333;
            stroke: #333;
        }
        #iconSizeControl {
            background: white;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        #iconSizeControl label {
            font-size: 12px;
        }
        #busStopForm {
            border-top: 1px solid #ccc;
            padding-top: 10px;
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            width: 100%;
        }
        #busStopForm input, #busStopForm select {
             flex-grow: 1;
        }
        #weather-buttons, #departure-arrival-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        #weather-buttons button, #departure-arrival-buttons button {
            padding: 4px 8px;
            font-size: 14px;
            margin: 0;
            border: 1px solid #ccc;
            background-color: white;
            cursor: pointer;
        }
        #weather-buttons button.selected, #departure-arrival-buttons button.selected {
            background-color: #007bff;
            color: white;
        }

        #areaInfoModal .modal-content-box {
            min-width: 600px;
            max-width: 80vw;
        }
        .area-info-section {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .area-info-section h4 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .area-info-section .shape-group {
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .area-info-section .shape-group p {
            font-weight: bold;
            margin: 0 0 5px 0;
            width: 100%;
        }
        .area-info-section .shape-group label {
            margin-right: 0;
            font-weight: normal;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .popup-delete-button {
            margin-top: 8px;
            padding: 4px 8px;
            width: 100%;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .popup-edit-button {
            margin-top: 5px;
            padding: 4px 8px;
            width: 100%;
            background-color: #ffc107;
            color: #212529;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .popup-direction-buttons {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            justify-content: center;
        }
        .popup-direction-buttons button {
            padding: 2px 8px;
            font-size: 12px;
            flex-grow: 1;
        }
        .popup-direction-buttons button.selected {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }
        /* START: Weather control styles */
        .leaflet-control-weather, .leaflet-control-visibility, .leaflet-control-road-condition {
            display: flex;
            gap: 2px;
            background: rgba(255, 255, 255, 0.8);
            padding: 3px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .leaflet-control-weather button, .leaflet-control-visibility button, .leaflet-control-road-condition button {
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
        }
        .leaflet-control-weather button:hover, .leaflet-control-visibility button:hover, .leaflet-control-road-condition button:hover {
            background-color: #f4f4f4;
        }
        .leaflet-control-weather button.selected, .leaflet-control-visibility button.selected, .leaflet-control-road-condition button.selected {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }

        /* START: Polyline color palette styles */
        .leaflet-control-color-palette {
            display: none; /* 初期状態では非表示にする */
            gap: 2px;
            background: rgba(255, 255, 255, 0.8);
            padding: 3px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            cursor: pointer;
            border: 2px solid #fff;
            border-radius: 4px;
        }
        .color-swatch.selected {
            border-color: #000;
            box-shadow: 0 0 3px #000;
        }
        /* END: Polyline color palette styles */
		/* START: New Modal Layout Styles */
		.modal-body-grid {
			display: flex;
			gap: 5px;
			flex-grow: 1; /* Make body fill available space */
		}
		.modal-column {
			flex: 1;
			display: flex;
			flex-direction: column;
			gap: 5px;
		}
		.modal-section {
			border: 1px solid #e2e8f0;
			border-radius: 8px;
			padding: 15px;
			background-color: #fdfdfd;
		}
		.modal-section-title {
			font-weight: bold;
			margin: 0 0 10px 0;
			padding-bottom: 5px;
			border-bottom: 1px solid #e2e8f0;
		}

		/* Tab Navigation Styles */
		.tab-nav {
			display: flex;
			border-bottom: 1px solid #ccc;
			margin-bottom: 10px;
		}
		.tab-button {
			padding: 6px 12px; /* ★上下左右の余白を詰める */
			cursor: pointer;
			border: none;
			background-color: transparent;
			border-bottom: 3px solid transparent;
			margin-bottom: -1px; /* Overlap with container border */
			font-size: 13px; /* ★文字サイズを少し小さくして統一 */
		}
		.tab-button.active {
			border-bottom-color: #007bff;
			font-weight: bold;
			color: #007bff;
		}
		.tab-pane {
			display: none;
		}
		.tab-pane.active {
			display: block;
		}
		#reason-major-buttons {
			max-height: 350px;
			overflow-y: auto;
			padding-right: 5px;
		}
		/* END: New Modal Layout Styles */
		/* START: Favorite Modal Button Styles */
		/* お気に入りモーダル内の、各フィールド（「要因」など）のコンテナ */
		#favoriteDetailModal .modal-field {
			display: flex;
			align-items: flex-start;
		}
		/* お気に入りモーダル内の、ボタンと追加フォームを囲む右側のコンテナ */
		#favoriteDetailModal .modal-field > div {
			flex: 1;
			display: flex;
			flex-direction: column;
			gap: 10px;
		}
		/* ボタンを直接囲むコンテナのスタイル */
		#favoriteDetailModal .multi-select {
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
		}
		/* ボタン自体のスタイル */
		#favoriteDetailModal .multi-select button {
			flex-grow: 0;
			flex-shrink: 0;
			width: auto;
			font-size: 14px;
			padding: 4px 10px;
		}
		/* END: Favorite Modal Button Styles */
		#tripNumber.warning {
			border: 2px solid red !important;
			background-color: #fff0f0;
		}
		.leaflet-control-weather.warning,
		.leaflet-control-visibility.warning,
		.leaflet-control-road-condition.warning {
			border: 2px solid red;
			border-radius: 4px;
			background-color: #fff0f0;
		}
		/* ★★★ ここから追加 ★★★ */
		/* 介入事由アコーディオンのスタイル */
		#reason-major-buttons details {
			border: 1px solid #e0e0e0;
			border-radius: 4px;
			margin-bottom: 5px;
			background-color: #fdfdfd;
		}
		#reason-major-buttons summary {
			padding: 8px 12px;
			font-weight: bold;
			cursor: pointer;
			outline: none;
			list-style: none; /* 三角マークを消す */
			display: flex;
			align-items: center;
			font-size: 11px; /* ★★★ 文字サイズを小さくする指定を追加 ★★★ */
		}
		#reason-major-buttons summary::-webkit-details-marker {
			display: none; /* Webkitブラウザ用の三角マーク消去 */
		}
		#reason-major-buttons summary::before {
			content: '▶'; /* 閉じた状態のアイコン */
			margin-right: 8px;
			font-size: 0.8em;
			transition: transform 0.2s;
		}
		#reason-major-buttons details[open] > summary {
			border-bottom: 1px solid #e0e0e0;
			background-color: #f5f5f5;
		}
		#reason-major-buttons details[open] > summary::before {
			transform: rotate(90deg); /* 開いた状態のアイコン */
		}
		#reason-major-buttons details > div {
			padding: 10px;
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			background-color: #ffffff;
		}
		/* ★★★ ここまで追加 ★★★ */
		/* ★★★ ここから追加 ★★★ */
		/* 状況詳細・介入操作ボタンのサイズ調整 */
		#customModal .modal-column:nth-child(2) .multi-select button {
			font-size: 13px;
			padding: 4px 8px;
		}

		/* 基本情報セクションのフォントサイズ調整 */
		.basic-info-section .modal-section-title {
			font-size: 14px; /* タイトルのフォントサイズ */
		}
		.basic-info-section .modal-field p strong {
			font-size: 13px; /* 「記録日時」「メモ」のフォントサイズ */
		}
		.basic-info-section input[type="datetime-local"],
		.basic-info-section textarea {
			font-size: 13px; /* 入力欄のフォントサイズ */
		}
		/* ★★★ ここまで追加 ★★★ */
		/* 介入事由タブの表示を整える */
		#reason-tab-nav {
			flex-wrap: wrap; /* タブがコンテナ幅を超えたら、下に折り返すようにする */
			gap: 4px 0;      /* 折り返した際の上下の隙間を調整 */
			margin-bottom: 12px; /* ★タブの下の余白を広げる */
		}

		#reason-tab-nav .tab-button {
			white-space: nowrap; /* ボタン内のテキストが改行されるのを防ぐ */
			flex-shrink: 0;      /* ボタンが縮んでしまうのを防ぐ */
			font-size: 13px;     /* ★文字を少し小さく */
			padding: 6px 10px;   /* ★ボタンの左右の余白を詰める */
		}
		#reason-tab-content .multi-select button {
			font-size: 13px;     /* 文字を2段階小さく */
			padding: 4px 8px;    /* ボタンの上下左右の余白を詰める */
			margin: 2px;         /* ボタン同士の隙間を少し詰める */
		}
		/* --- 新規項目追加フォームのサイズ調整 --- */

		/* 入力フォームの高さと文字サイズを調整 */
		.major-reason-input-group input,
		.modal-input-group input {
			font-size: 12px;
			padding-top: 6px;    /* ★上の余白 */
			padding-bottom: 6px; /* ★下の余白 */
		}

		/* 追加・削除ボタンの高さと文字サイズを調整 */
		.major-reason-input-group button,
		.modal-input-group button {
			font-size: 12px;
			padding: 6px 10px; /* ★上下の余白を調整 */
		}
		/* --- バス停通過記録モーダルのレイアウト調整 --- */
		#busStopRecordModal .modal-field {
			margin-bottom: 8px; /* ★各項目の下の余白を詰める */
		}

		#busStopRecordModal .modal-field p {
			margin-bottom: 4px; /* ★項目名の下の余白を詰める */
		}

		#busStopRecordModal input[type="text"],
		#busStopRecordModal input[type="datetime-local"],
		#busStopRecordModal select {
			font-size: 14px;
			padding: 5px 8px; /* ★入力欄の高さを調整 */
		}

		#busStopRecordModal #weather-buttons button,
		#busStopRecordModal #departure-arrival-buttons button {
			font-size: 13px;
			padding: 3px 8px; /* ★ボタンの高さを調整 */
		}
		#busStopArrivalButton {
			font-size: 12px;           /* 文字を小さく */
			padding: 4px 8px;          /* ボタンの余白を詰めて小さく */
			background-color: #ffc107; /* 背景を黄色に */
			color: #212529;            /* 文字色を黒に */
			border-color: #e0a800;     /* 枠線の色を調整 */
		}
		#busStopArrivalButton:hover {
			background-color: #e0a800; /* マウスを乗せたときの色 */
		}
		/* 介入事由の選択結果 表示エリアのスタイル */
		#selectedReasonDisplay {
			background-color: #f8f9fa;  /* 背景色を薄いグレーに */
			border: 1px solid #ced4da;   /* 枠線を設定 */
			color: #E4080A;             /* 文字色を濃い赤に */
			font-weight: bold;           /* 文字を太字にして強調 */
			padding: 12px;               /* 内側の余白を十分に確保 */
			border-radius: 6px;          /* 角を少し丸くする */
			margin-top: 10px;
			min-height: 24px;
			box-shadow: inset 0 1px 2px rgba(0,0,0,0.075); /* 内側に少し影を付ける */
		}
		
    </style>
</head>
<body>
    <div id="modeSelector">
        <h2>表示モードを選んでください</h2>
        <button onclick="setMode('pc')">PC版</button>
        <button onclick="setMode('mobile')">スマホ版</button>
    </div>

    <div id="controls">
        <button onclick="setDirection('往路')" class="direction-button control-button-small" data-mobile>往路</button>
        <button onclick="setDirection('復路')" class="direction-button control-button-small" data-mobile>復路</button>
        <input type="text" id="projectName" placeholder="案件名を入力" oninput="this.classList.remove('warning')">
        
        <select id="tripNumber">
            <option value="">便数を選択</option>
			<option value="テスト">テスト</option>
            <option value="1便">1便</option>
            <option value="2便">2便</option>
            <option value="3便">3便</option>
            <option value="4便">4便</option>
            <option value="5便">5便</option>
            <option value="6便">6便</option>
            <option value="7便">7便</option>
            <option value="8便">8便</option>
            <option value="9便">9便</option>
            <option value="10便">10便</option>
            <option value="11便">11便</option>
            <option value="12便">12便</option>
            <option value="13便">13便</option>
            <option value="14便">14便</option>
            <option value="15便">15便</option>
            <option value="16便">16便</option>
            <option value="17便">17便</option>
            <option value="18便">18便</option>
            <option value="19便">19便</option>
            <option value="20便">20便</option>
            <option value="21便">21便</option>
            <option value="22便">22便</option>
            <option value="23便">23便</option>
            <option value="24便">24便</option>
            <option value="25便">25便</option>
            <option value="26便">26便</option>
            <option value="27便">27便</option>
            <option value="28便">28便</option>
            <option value="29便">29便</option>
            <option value="30便">30便</option>
            <option value="31便">31便</option>
            <option value="32便">32便</option>
            <option value="33便">33便</option>
            <option value="34便">34便</option>
            <option value="35便">35便</option>
            <option value="36便">36便</option>
            <option value="37便">37便</option>
            <option value="38便">38便</option>
            <option value="39便">39便</option>
            <option value="40便">40便</option>
            <option value="41便">41便</option>
            <option value="42便">42便</option>
            <option value="43便">43便</option>
            <option value="44便">44便</option>
            <option value="45便">45便</option>
            <option value="46便">46便</option>
            <option value="47便">47便</option>
            <option value="48便">48便</option>
            <option value="49便">49便</option>
            <option value="50便">50便</option>
        </select>
        
        <button onclick="logCurrentGPS()" data-mobile class="gps-button">GPSで記録</button>
        <button onclick="downloadPinsAsXLSX()" class="control-button-small">ピン保存</button>
		<button onclick="openPinFilterModal()" class="control-button-small">ピン読込</button>
		<input type="file" id="pinFileInput" accept=".json" onchange="handlePinFiles(event)" multiple style="display: none;">
		<input type="file" id="xlsxFileInput" accept=".xlsx, .xls" onchange="handleXLSXFile(event)" style="display: none;">
        <button id="toggleLabelsButton" onclick="toggleLabels()" class="control-button-small">エリア名</button>
        <button onclick="saveAllSettings()" class="control-button-small">設定保存</button>
        <button onclick="document.getElementById('settingsFileInput').click()" class="control-button-small">設定読込</button>
        <input type="file" id="settingsFileInput" accept=".json" onchange="loadAllSettings(event)" style="display:none;">
        <input type="text" id="geoFileName" placeholder="保存ファイル名">
        <button onclick="exportGeoJSON()" class="control-button-small">線/エリアを保存</button>
        
        <button onclick="openLoadChoiceModal()" class="control-button-small">線/エリア読込</button>
        <input type="file" id="jsonFileInput" accept=".json" onchange="importJsonFile(event)" style="display:none;">
        <input type="file" id="kmlFileInput" accept=".kml,.kmz" onchange="importKmlKmzFile(event)" style="display:none;">
        
        <button id="toggleBusStopFormButton" onclick="toggleBusStopForm()" class="control-button-small">バス停名登録</button>
        <div id="busStopForm" style="display: none;">
             <input type="text" id="newBusStopName" placeholder="新しいバス停名を入力">
             <button onclick="addBusStop()">登録</button>
             <button onclick="deleteAllBusStops()">すべて削除</button>
        </div>
        <div id="bus-stop-buttons-container"></div>
        <div id="offlineStatus"></div> 
    </div>

    <div id="map"></div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet.magnifyingglass@1.0.0/leaflet.magnifyingglass.min.js"></script>
    <script src="https://unpkg.com/@tmcw/togeojson@4.1.0/dist/togeojson.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <script>
    let map, currentDirection = "", showLabels = true;
    const markerLayerGroup = L.layerGroup();
    const drawnItems = new L.FeatureGroup();
    const labelMap = new Map();
    let pendingLog = null;
    let editingPinData = null; // 編集中のピンデータを保持する変数
    let buttonStates = {};
    let streetParkingAvoidanceRecordTime = null;
    let isWaitingForStreetParkingDoubleClick = false;
    const GAS_URL = "https://script.google.com/macros/s/AKfycbwJALeOYLDVCP4LsE7BimfEr8suToqVyiLrlzgVPa8A5CCfXq2H9mbZmWESqGmCPmkr/exec";

    let offlineLogQueue = [];
    const OFFLINE_QUEUE_KEY = 'interventionMapOfflineQueue';
    const SEND_TIMEOUT = 30000; 

    let favoriteConfigurations = {};
    const FAVORITES_STORAGE_KEY = 'interventionMapFavorites';
    const CUSTOM_AREA_INFO_KEY = 'customAreaInfoOptions';
    let activeFavoriteSlotToLog = null; 
    let isDeleteFavoriteModeActive = false;
    let favoriteButtonsControl = null; 
    let pendingFavoriteLog = null;

    let magnifyingGlass = null;
    let currentBaseLayer = null;
    let selectedWeather = ""; // Variable to store selected weather
    let selectedVisibility = ""; // 視界の状態
    let selectedRoadCondition = ""; // 路面状況

    // 手動設置アイコン関連のグローバル変数
    const placemarkLayer = L.layerGroup();
    let placemarkIconSize = 24;
    let activePlacemarkType = null; // 現在選択中のアイコンタイプ
    
    // アイコンのSVG定義
    const PLACEMARK_ICONS = {
        'バス停': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="6" cy="17" r="2" /><circle cx="18" cy="17" r="2" /><path d="M4 17h-2v-11a1 1 0 0 1 1 -1h14a5 7 0 0 1 5 7v5h-2m-4 0h-8" /><path d="M16 5l1.5 7h4.5" /><path d="M2 10h15" /><path d="M7 5l0 5" /><path d="M12 5l0 5" /></svg>`,
        '信号': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="7" y="3" width="10" height="18" rx="5" /><circle cx="12" cy="8" r="1" /><circle cx="12" cy="12" r="1" /><circle cx="12" cy="16" r="1" /></svg>`,
        '横断歩道': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4.5 17h15" /><path d="M4.5 12h15" /><path d="M4.5 7h15" /></svg>`,
        '踏切': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 21v-18" /><path d="M20 21v-18" /><path d="M4 6h16" /><path d="M4 12h16" /><path d="M4 18h16" /></svg>`,
        'トンネル': `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 14h14" /><path d="M8.5 10h7" /><path d="M3 21h18" /><path d="M10 21v-8a2 2 0 1 1 4 0v8" /><path d="M3 14a9 9 0 0 1 18 0" /></svg>`,
    };


    const MLIT_FACTORS_KEY = 'interventionMlitFactorMap';
    let userMlitFactorMap = {}; 
    let pendingMinorReasonForMlit = null; 
    const mlitFactors = [
        '路上駐車回避', '直進時の走行逸脱回避', '前方車両や障害物に対する危険回避', '直進時の周辺の交通参加者に対する危険回避',
        '右左折時の周辺の交通参加者に対する危険回避', '円滑に走行するための手動介入', '自動運行装置の作動不良時の安全確保', 'その他'
    ];

    const BUS_STOPS_KEY = 'busStopNames';
    let currentBusStopInfo = {};
    
    let pendingAreaLayer = null;
    let layerToStyle = null; // For individual style editing
    let isEditingWorkflow = false; // Flag for edit -> style -> info workflow
    
    const globalPolygonStyles = { 
        color: '#E53E3E',     // ポリゴン枠線: 赤色
        weight: 2,            // ポリゴン枠線の太さ: 2px
        opacity: 0.1,         // ポリゴン枠線の不透明度: 10%
        fillColor: '#F6E05E', // ポリゴン塗りつぶし: 黄色
        fillOpacity: 0.3      // ポリゴン塗りつぶしの不透明度: 30%
    };
    const globalPolylineStyles = {
        color: '#3388ff',     // ポリライン: 青色
        weight: 4,            // ポリラインの太さ: 4px
        opacity: 1.0          // ポリラインの不透明度: 100%
    };
    const polylineColors = ['#3388ff', '#ff4136', '#2ecc40', '#ffdc00', '#f012be']; // 青, 赤, 緑, 黄, ピンク
    let currentPolylineColor = polylineColors[0]; // デフォルトは青
    let drawControl; // 描画コントロールを後から操作するためにグローバル変数化
	let pinLoadFilter = '全て'; // ピン読み込み時のフィルター状態を保持

    const yellowIcon = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [18, 30], iconAnchor: [9, 30], popupAnchor: [1, -28], shadowSize: [30, 30]
    });
    const blueIcon = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [18, 30], iconAnchor: [9, 30], popupAnchor: [1, -28], shadowSize: [30, 30]
    });
    /*
     ★★★ ここに大項目,中項目で打ち込んでください ★★★
    */    
    const interventionReasonCSV = `大項目,中項目
		路駐車回避できず,回避経路が出ず失敗(路駐車判定の失敗）
		路駐車回避できず,対向車接近により失敗
		路駐車回避できず,後方からの接近車による失敗
		路駐車回避できず,回避先が危険と判断し失敗（人が近い・幅が狭い等）
		路駐車回避できず,路駐車が複数台あり回避後の再回避が失敗
		回避できず（路駐車以外）,認識できず回避できなかった（路駐車以外：メモに記載）
		回避できず（路駐車以外）,認識し止まってしまった（路駐車以外：メモに記載）
		回避走行中の介入,対向車と対面してしまった
		回避走行中の介入,路駐車が複数台あり回避後の再回避が失敗
		回避走行中の介入,回避中危険と判断し失敗（人が近い・幅が狭い等）
		回避走行中の介入,安全確保の為の介入（死角等）
		回避からの復帰失敗,路駐車が複数台あり回避後の再回避が失敗
		回避からの復帰失敗,復帰先の縁石や壁などにぶつかりそう
		回避からの復帰失敗,自転車やバイク等が後方に居り失敗
		回避からの復帰失敗,対向車と対面してしまった
		回避からの復帰失敗,復帰先後方から車両等の接近
		横断歩道（cross walk関連）,歩行者等の接近で停止した為（早く抜け出す必要があった）
		横断歩道（cross walk関連）,歩行待機者や歩行者等がいるのに止まらず
		横断歩道（cross walk関連）,他の交通の妨げにならないように（歩行者渡らず、譲り合い）
		横断歩道（cross walk関連）,横断歩道接近者が途切れず（横断歩道付近に複数人歩行者有）
		横断歩道（cross walk関連）,誤検知（何もないのに止まってしまう等）
		対向車検知,対向車検知（大型車両やトラック）
		対向車検知,対向車検知（中央線近くを走行している車両）
		対向車検知,対向車検知（中央線を割って走行している車両）
		対向車検知,対向車検知（幅員が狭い）
		対向車検知,対向車接近により路駐回避失敗
		前方車両急減速・急停止,急減速
		前方車両急減速・急停止,急停止
		障害物検知,誤検知（何かわかれば何を誤検知したか記載）
		障害物検知,落下物（何かを記載）
		障害物検知,植栽
		障害物検知,看板
		障害物検知,電柱
		障害物検知,砂煙/排気ガス/煙
		障害物検知,水たまり
		障害物検知,霧
		障害物検知,雪
		障害物検知,自転車やバイク等の路上駐輪
		障害物検知,不明
		障害物検知,その他（何かを記載）
		障害物　誤検知,誤検知（何かわかれば何を誤検知したか記載）
		信号,誤検知（赤→青）
		信号,誤検知（青→赤）
		信号,ジレンマゾーン（黄色で進入しそうになった等）
		信号,検知できず
		信号,未対応信号（点滅信号や一部の矢印信号等）
		交差点右折失敗,対向車検知ができていない
		交差点右折失敗,他の交通の妨げにならないように
		交差点右折失敗,交差点取り残され（早期交差点脱出のため）
		交差点右折失敗,他の車両が近く停止してしまった
		交差点右折失敗,右折先で左に寄ってしまい介入
		交差点右折失敗,右折先の対向車が近く介入
		交差点右折失敗,その他（詳細を記載）
		交差点右折失敗（横断歩道）,歩行者等の接近で停止した為（早く抜け出す必要があった）
		交差点右折失敗（横断歩道）,歩行待機者や歩行者等がいるのに止まらず
		交差点右折失敗（横断歩道）,他の交通の妨げにならないように（歩行者渡らず、譲り合い）
		交差点右折失敗（横断歩道）,横断歩道接近者が途切れず（横断歩道付近に複数人歩行者有）
		交差点右折失敗（横断歩道）,誤検知（何もないのに止まってしまう等）
		交差点左折失敗,死角検知による急減速（blind stop)
		交差点左折失敗,他の交通の妨げにならないように
		交差点左折失敗,交差点取り残され（早期交差点脱出のため）
		交差点左折失敗,非優先道路からの無理な進入（右折車両の無理な進入等）
		交差点左折失敗,他の車両が近く停止してしまった
		交差点左折失敗,左折先で左に寄ってしまい介入
		交差点左折失敗,左折先の対向車が近く介入
		交差点左折失敗,その他（詳細を記載）
		交差点左折失敗（横断歩道）,歩行者等の接近で停止した為（早く抜け出す必要があった）
		交差点左折失敗（横断歩道）,歩行待機者や歩行者等がいるのに止まらず
		交差点左折失敗（横断歩道）,他の交通の妨げにならないように（歩行者渡らず、譲り合い）
		交差点左折失敗（横断歩道）,横断歩道接近者が途切れず（横断歩道付近に複数人歩行者有）
		交差点左折失敗（横断歩道）,誤検知（何もないのに止まってしまう等）
		交差点直進失敗,非優先道路からの無理な進入
		交差点直進失敗,優先道路側の車両認識が遅れた為
		交差点直進失敗,対向車が自車経路上に居り進めなかった為
		交差点直進失敗,その他（詳細を記載）
		交差点直進失敗（横断歩道）,歩行者等の接近で停止した為（早く抜け出す必要があった）
		交差点直進失敗（横断歩道）,歩行待機者や歩行者等がいるのに止まらず
		交差点直進失敗（横断歩道）,他の交通の妨げにならないように（歩行者渡らず、譲り合い）
		交差点直進失敗（横断歩道）,横断歩道接近者が途切れず（横断歩道付近に複数人歩行者有）
		交差点直進失敗（横断歩道）,誤検知（何もないのに止まってしまう等）
		直進時　歩行者・自転車等の挙動,車両に近く急停止(減速)したため（surround obstacl)
		直進時　歩行者・自転車等の挙動,飛び出し検知
		直進時　歩行者・自転車等の挙動,歩行者や自転車の追越の為の介入
		直進時　歩行者・自転車等の挙動,歩行者や自転車との距離が近く安全の為介入
		右左折時　歩行者・自転車等の挙動,車両に近く急停止(減速)したため（surround obstacl)
		右左折時　歩行者・自転車等の挙動,飛び出し検知
		右左折時　歩行者・自転車等の挙動,歩行者や自転車の追越の為の介入
		右左折時　歩行者・自転車等の挙動,歩行者や自転車との距離が近く安全の為介入
		優先道路走行車両に譲られたため,対向車に譲られたため
		追い越され,急なカットインで危険を感じた為
		危険運転（他車両が）,煽られ
		危険運転（他車両が）,急減速などの嫌がらせ
		危険運転（他車両が）,急な割込み
		危険運転（他車両が）,急な割込み（道路以外、駐車場など）
		危険運転（他車両が）,その他
		優先道路走行車両通過待ち,優先道路走行車両通過待ち（右左折時）
		優先道路走行車両通過待ち,優先道路走行車両通過待ち（直進時）
		レーンチェンジ失敗,レーンチェンジ先後方に車両がいてできない
		レーンチェンジ失敗,レーンチェンジ先側方に車両がいてできない
		レーンチェンジ失敗,距離が短くできなかった
		レーンチェンジ失敗,交通状況を見て早めに手動でレーンチェンジ
		レーンチェンジ失敗,路駐車がいてできなかった
		信号連携/路車協調不備,実際の信号情報と差異があった（赤→青）
		信号連携/路車協調不備,実際の信号情報と差異があった（青→赤）
		信号連携/路車協調不備,実際の状況と差異があった
		信号連携/路車協調不備,連携非稼働
		信号連携/路車協調不備,情報が届かず
		システム,システムエラーで動かなかった
		システム,システムエラーで急停止・急減速した
		システム,システムエラーで挙動がおかしくなった
		システム,死角検知による急減速（blind stop)
		システム,vehicle error
		システム,その他
		システム,原因不明`;

    /*
     ★★★ ここにカテゴリ分けデータを追加してください ★★★
    */
    const majorReasonCategories = {
        "回避関連": [
            "路駐車回避できず",
            "回避できず（路駐車以外）",
            "回避走行中の介入",
            "回避からの復帰失敗",
            "レーンチェンジ失敗"
        ],
        "交差点関連": [
            "交差点右折失敗",
            "交差点右折失敗（横断歩道）",
            "交差点左折失敗",
            "交差点左折失敗（横断歩道）",
            "交差点直進失敗",
            "交差点直進失敗（横断歩道）"
        ],
        "周辺交通": [
            "横断歩道（cross walk関連）",
            "対向車検知",
            "前方車両急減速・急停止",
            "直進時　歩行者・自転車等の挙動",
            "右左折時　歩行者・自転車等の挙動",
            "優先道路走行車両に譲られたため",
            "追い越され",
            "危険運転（他車両が）",
            "優先道路走行車両通過待ち"
        ],
        "障害物検知・誤検知": [
            "障害物検知",
            "障害物　誤検知"
        ],
        "信号・信号連携・路車協調": [
            "信号",
            "信号連携/路車協調不備"
        ],
        "システム": [
            "システム"
        ]
    };
    /*
     ★★★ここから下に中項目,国交省用で入れてください。★★★
    */
	    const defaultMlitFactorMap = {
        '回避経路が出ず失敗(路駐車判定の失敗）': '路上駐車回避',
        '対向車接近により失敗': '路上駐車回避',
        '後方からの接近車による失敗': '路上駐車回避',
        '回避先が危険と判断し失敗（人が近い・幅が狭い等）': '路上駐車回避',
        '路駐車が複数台あり回避後の再回避が失敗': '路上駐車回避',
        '認識できず回避できなかった（路駐車以外：メモに記載）': '前方車両や障害物に対する危険回避',
        '認識し止まってしまった（路駐車以外：メモに記載）': '前方車両や障害物に対する危険回避',
        '対向車と対面してしまった': '路上駐車回避',
        '回避中危険と判断し失敗（人が近い・幅が狭い等）': '路上駐車回避',
        '安全確保の為の介入（死角等）': '直進時の周辺の交通参加者に対する危険回避',
        '復帰先の縁石や壁などにぶつかりそう': '前方車両や障害物に対する危険回避',
        '自転車やバイク等が後方に居り失敗': '直進時の周辺の交通参加者に対する危険回避',
        '復帰先後方から車両等の接近': '路上駐車回避',
        '歩行者等の接近で停止した為（早く抜け出す必要があった）': '円滑に走行するための手動介入',
        '歩行待機者や歩行者等がいるのに止まらず': '自動運行装置の作動不良時の安全確保',
        '他の交通の妨げにならないように（歩行者渡らず、譲り合い）': '円滑に走行するための手動介入',
        '横断歩道接近者が途切れず（横断歩道付近に複数人歩行者有）': '円滑に走行するための手動介入',
        '誤検知（何もないのに止まってしまう等）': '自動運行装置の作動不良時の安全確保',
        '対向車検知（大型車両やトラック）': '前方車両や障害物に対する危険回避',
        '対向車検知（中央線近くを走行している車両）': '前方車両や障害物に対する危険回避',
        '対向車検知（中央線を割って走行している車両）': '前方車両や障害物に対する危険回避',
        '対向車検知（幅員が狭い）': '前方車両や障害物に対する危険回避',
        '対向車接近により路駐回避失敗': '路上駐車回避',
        '急減速': '前方車両や障害物に対する危険回避',
        '急停止': '前方車両や障害物に対する危険回避',
        '誤検知（何かわかれば何を誤検知したか記載）': '自動運行装置の作動不良時の安全確保',
        '落下物（何かを記載）': '前方車両や障害物に対する危険回避',
        '植栽': '前方車両や障害物に対する危険回避',
        '看板': '前方車両や障害物に対する危険回避',
        '電柱': '前方車両や障害物に対する危険回避',
        '砂煙/排気ガス/煙': '自動運行装置の作動不良時の安全確保',
        '水たまり': '自動運行装置の作動不良時の安全確保',
        '霧': '自動運行装置の作動不良時の安全確保',
        '雪': '自動運行装置の作動不良時の安全確保',
        '自転車やバイク等の路上駐輪': '前方車両や障害物に対する危険回避',
        '不明': '前方車両や障害物に対する危険回避',
        'その他（何かを記載）': '前方車両や障害物に対する危険回避',
        '誤検知（赤→青）': '自動運行装置の作動不良時の安全確保',
        '誤検知（青→赤）': '自動運行装置の作動不良時の安全確保',
        'ジレンマゾーン（黄色で進入しそうになった等）': '円滑に走行するための手動介入',
        '検知できず': '自動運行装置の作動不良時の安全確保',
        '未対応信号（点滅信号や一部の矢印信号等）': 'その他',
        '対向車検知ができていない': '右左折時の周辺の交通参加者に対する危険回避',
        '他の交通の妨げにならないように': '円滑に走行するための手動介入',
        '交差点取り残され（早期交差点脱出のため）': '円滑に走行するための手動介入',
        '他の車両が近く停止してしまった': '右左折時の周辺の交通参加者に対する危険回避',
        '右折先で左に寄ってしまい介入': '右左折時の周辺の交通参加者に対する危険回避',
        '右折先の対向車が近く介入': '右左折時の周辺の交通参加者に対する危険回避',
        'その他（詳細を記載）': '直進時の周辺の交通参加者に対する危険回避',
        '死角検知による急減速（blind stop)': '円滑に走行するための手動介入',
        '非優先道路からの無理な進入（右折車両の無理な進入等）': '右左折時の周辺の交通参加者に対する危険回避',
        '左折先で左に寄ってしまい介入': '右左折時の周辺の交通参加者に対する危険回避',
        '左折先の対向車が近く介入': '右左折時の周辺の交通参加者に対する危険回避',
        '非優先道路からの無理な進入': '直進時の周辺の交通参加者に対する危険回避',
        '優先道路側の車両認識が遅れた為': '直進時の周辺の交通参加者に対する危険回避',
        '対向車が自車経路上に居り進めなかった為': '直進時の周辺の交通参加者に対する危険回避',
        '車両に近く急停止(減速)したため（surround obstacl)': '右左折時の周辺の交通参加者に対する危険回避',
        '飛び出し検知': '右左折時の周辺の交通参加者に対する危険回避',
        '歩行者や自転車の追越の為の介入': '右左折時の周辺の交通参加者に対する危険回避',
        '歩行者や自転車との距離が近く安全の為介入': '右左折時の周辺の交通参加者に対する危険回避',
        '対向車に譲られたため': '円滑に走行するための手動介入',
        '急なカットインで危険を感じた為': '前方車両や障害物に対する危険回避',
        '煽られ': '直進時の周辺の交通参加者に対する危険回避',
        '急減速などの嫌がらせ': '前方車両や障害物に対する危険回避',
        '急な割込み': '直進時の周辺の交通参加者に対する危険回避',
        '急な割込み（道路以外、駐車場など）': '直進時の周辺の交通参加者に対する危険回避',
        'その他': '自動運行装置の作動不良時の安全確保',
        '優先道路走行車両通過待ち（右左折時）': '右左折時の周辺の交通参加者に対する危険回避',
        '優先道路走行車両通過待ち（直進時）': '直進時の周辺の交通参加者に対する危険回避',
        'レーンチェンジ先後方に車両がいてできない': '直進時の周辺の交通参加者に対する危険回避',
        'レーンチェンジ先側方に車両がいてできない': '直進時の周辺の交通参加者に対する危険回避',
        '距離が短くできなかった': '直進時の周辺の交通参加者に対する危険回避',
        '交通状況を見て早めに手動でレーンチェンジ': '円滑に走行するための手動介入',
        '路駐車がいてできなかった': '路上駐車回避',
        '実際の信号情報と差異があった（赤→青）': 'その他',
        '実際の信号情報と差異があった（青→赤）': 'その他',
        '実際の状況と差異があった': 'その他',
        '連携非稼働': 'その他',
        '情報が届かず': 'その他',
        'システムエラーで動かなかった': '自動運行装置の作動不良時の安全確保',
        'システムエラーで急停止・急減速した': '自動運行装置の作動不良時の安全確保',
        'システムエラーで挙動がおかしくなった': '自動運行装置の作動不良時の安全確保',
        'vehicle error': '自動運行装置の作動不良時の安全確保',
        '原因不明': '自動運行装置の作動不良時の安全確保'
    };
	
    function parseInterventionReasonCSV(csvText) {
        const lines = csvText.trim().split(/\r?\n/);
        const result = {};
        if (lines.length === 0) return result;
        const dataLines = lines.slice(1);
        dataLines.forEach(line => {
            const parts = line.split(',');
            if (parts.length >= 2) {
                const major = parts[0].trim();
                const minor = parts[1].trim();
                if (major && minor) {
                    if (!result[major]) result[major] = [];
                    if (!result[major].includes(minor)) result[major].push(minor);
                }
            }
        });
        return result;
    }
    const defaultInterventionReasonData = parseInterventionReasonCSV(interventionReasonCSV);
    let userAddedReasons = {};
    let interventionReasonData = {}; 
    let currentMajorReason = null;
    let currentSelectedMinorReasons = [];
    let currentlySelectedMajorButton = null; 

    function loadUserAddedReasons() {
        const storedReasons = localStorage.getItem('userAddedInterventionReasons');
        if (storedReasons) {
            try {
                userAddedReasons = JSON.parse(storedReasons);
                if (typeof userAddedReasons !== 'object' || userAddedReasons === null) {
                    userAddedReasons = {};
                }
            } catch (e) {
                console.error("Error parsing userAddedInterventionReasons from localStorage:", e);
                userAddedReasons = {};
            }
        } else {
            userAddedReasons = {};
        }
        interventionReasonData = { ...defaultInterventionReasonData };
        for (const major in userAddedReasons) {
            if (userAddedReasons.hasOwnProperty(major)) {
                if (!interventionReasonData[major]) {
                    interventionReasonData[major] = Array.isArray(userAddedReasons[major]) ? [...userAddedReasons[major]] : [];
                } else {
                    if(Array.isArray(userAddedReasons[major])) {
                        userAddedReasons[major].forEach(minor => {
                            if (!interventionReasonData[major].includes(minor)) {
                                interventionReasonData[major].push(minor);
                            }
                        });
                    }
                }
            }
        }
    }

    function loadMlitFactorMap() {
        const storedMap = localStorage.getItem(MLIT_FACTORS_KEY);
        if (storedMap) {
            try {
                userMlitFactorMap = JSON.parse(storedMap);
            } catch (e) {
                console.error("Failed to parse MLIT Factor Map from localStorage", e);
                userMlitFactorMap = {};
            }
        }
    }

    function getMlitFactorForMinorReason(minorReasonsString) {
        if (!minorReasonsString) return "";
        const minorReasons = minorReasonsString.split(' : ');
        const mlitFactorsFound = minorReasons.map(reason => {
            const trimmedReason = reason.trim();
            // ユーザー定義のマップを優先してチェック
            if (userMlitFactorMap[trimmedReason]) {
                return userMlitFactorMap[trimmedReason];
            }
            // デフォルトのマップをチェック
            if (defaultMlitFactorMap[trimmedReason]) {
                return defaultMlitFactorMap[trimmedReason];
            }
            return 'その他'; // マッピングがない場合のフォールバック
        });
        // 重複を削除して結合
        return [...new Set(mlitFactorsFound)].join(' : ');
    }

    loadUserAddedReasons();
    loadMlitFactorMap();

    function saveUserAddedReasons() {
        localStorage.setItem('userAddedInterventionReasons', JSON.stringify(userAddedReasons));
    }

    function loadOfflineQueue() {
        const storedQueue = localStorage.getItem(OFFLINE_QUEUE_KEY);
        if (storedQueue) {
            offlineLogQueue = JSON.parse(storedQueue);
        }
        updateOfflineStatus();
    }

    function saveOfflineQueue() {
        localStorage.setItem(OFFLINE_QUEUE_KEY, JSON.stringify(offlineLogQueue));
        updateOfflineStatus();
    }
    
    function updateOfflineStatus() {
        const statusDiv = document.getElementById('offlineStatus');
        if (offlineLogQueue.length > 0) {
            statusDiv.textContent = `未送信ログ: ${offlineLogQueue.length}件。次回送信時に再試行します。`;
            statusDiv.style.display = 'block';
        } else {
            statusDiv.textContent = '';
            statusDiv.style.display = 'none';
        }
    }

    function addLogToOfflineQueue(logData) {
        logData.offlineId = crypto.randomUUID();
        logData.queuedTimestamp = Date.now();
        offlineLogQueue.push(logData);
        saveOfflineQueue();
    }

    async function processOfflineQueue() {
        if (offlineLogQueue.length === 0) return;
        console.log(`Processing offline queue. ${offlineLogQueue.length} logs pending.`);
        const logToSend = offlineLogQueue[0]; 

        const formData = new FormData();
        for (const key in logToSend.formDataObject) {
            formData.append(key, logToSend.formDataObject[key]);
        }
        
        console.log("Retrying offline log:", logToSend);
        try {
            const response = await fetch(GAS_URL, { method: "POST", body: formData });
            if (!response.ok) throw new Error(`GAS request failed with status ${response.status}`);
            const text = await response.text();
            
            console.log("Offline log sent successfully:", text, logToSend.formDataObject["記録日時"]);
            
            // ▼▼▼ 修正箇所 START ▼▼▼
            // オフラインデータの送信成功後、ピンを地図に作成する処理を追加
            const pinData = logToSend.formDataObject;
            if (pinData.recordType !== 'delete' && pinData.recordType !== 'update') {
                 const latlng = L.latLng(parseFloat(pinData["緯度"]), parseFloat(pinData["経度"]));
                 const areaInfo = getAreaInfoFromPoint(latlng);
                 createAndAddMarker(pinData, areaInfo);
            }
            // ▲▲▲ 修正箇所 END ▲▲▲

            offlineLogQueue.shift(); 
            saveOfflineQueue();
            
            if (offlineLogQueue.length > 0) {
                setTimeout(processOfflineQueue, 1000); 
            }
        } catch (error) {
            console.error("Failed to send offline log:", error, logToSend.formDataObject["記録日時"]);
            updateOfflineStatus(); 
        }
    }

    function getCurrentJSTString(format = 'datetime', dateObj = new Date()) {
        const targetDate = new Date(dateObj.toLocaleString('en-US', { timeZone: 'Asia/Tokyo' }));
        const year = targetDate.getFullYear();
        const mm = String(targetDate.getMonth() + 1).padStart(2, '0');
        const dd = String(targetDate.getDate()).padStart(2, '0');
        const hh = String(targetDate.getHours()).padStart(2, '0');
        const mi = String(targetDate.getMinutes()).padStart(2, '0');
        const ss = String(targetDate.getSeconds()).padStart(2, '0');
        
        if (format === 'date') {
            return `${year}${mm}${dd}`;
        }
        if (format === 'datetime_filename') {
            return `${year}${mm}${dd}${hh}${mi}${ss}`;
        }
        if (format === 'datetime-local') {
            return `${year}-${mm}-${dd}T${hh}:${mi}:${ss}`; // 秒を追加
        }
        return `${year}/${mm}/${dd} ${hh}:${mi}:${ss}`;
    }


    function setMode(mode) {
        document.getElementById("modeSelector").style.display = "none";
        if (mode === 'mobile') {
            document.body.classList.add("mobile-mode");
        } else {
            document.body.classList.remove("mobile-mode");
        }
        if (!map) {
            initMap();
            processOfflineQueue(); 
        } else {
            map.invalidateSize();
        }
        checkProjectAndTripNumber();
    }
    function initMap() {
        if (map) return;

        map = L.map("map", { center: [35.1709, 136.8815], zoom: 18, doubleClickZoom: false, zoomControl: false });
        
// ★★★ ここから修正 ★★★
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OSM', maxZoom: 22, maxNativeZoom: 19 });
        const gsi = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', { attribution: '国土地理院', maxZoom: 22, maxNativeZoom: 18 });
        const photo = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/ort/{z}/{x}/{y}.jpg', { attribution: '航空写真', maxZoom: 22, maxNativeZoom: 18 });
        
        // 新しくGoogleの航空写真レイヤーを追加
        const googleSat = L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',{
            maxZoom: 22,
            subdomains:['mt0','mt1','mt2','mt3'],
            attribution: 'Google'
        });
        
        osm.addTo(map);
        currentBaseLayer = osm;

        // レイヤー選択メニューに新しい航空写真を追加
        const baseMaps = { 
            "OpenStreetMap": osm, 
            "国土地理院地図": gsi, 
            "航空写真 (国土地理院)": photo, // 既存のものを分かりやすくリネーム
            "航空写真 (Google)": googleSat    // Googleの航空写真を追加
        };
        L.control.layers(baseMaps, null, { position: 'bottomright' }).addTo(map);
// ★★★ ここまで修正 ★★★
        
        // START: Weather Control
        L.Control.Weather = L.Control.extend({
            options: {
                position: 'topleft'
            },
            onAdd: function(mapCtrl) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control-weather');
                L.DomEvent.disableClickPropagation(container);
                
                const weathers = ['晴れ', '曇り', '降雨', '降雪', '堆雪', 'キリ'];
                weathers.forEach(weather => {
                    const button = L.DomUtil.create('button', 'weather-button', container);
                    button.innerHTML = weather;
                    button.onclick = function() {
                        selectedWeather = weather;
                        container.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
                        this.classList.add('selected');
                    };
                });
                return container;
            },
            onRemove: function(mapCtrl) {}
        });
        map.addControl(new L.Control.Weather());
        // END: Weather Control

        L.Control.Visibility = L.Control.extend({
            options: { position: 'topleft' },
            onAdd: function(mapCtrl) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control-visibility');
                L.DomEvent.disableClickPropagation(container);
                const visibilities = ['良好', '逆光', '夕日', '西日', '夜'];
                visibilities.forEach(visibility => {
                    const button = L.DomUtil.create('button', '', container);
                    button.innerHTML = visibility;
                    button.onclick = function() {
                        selectedVisibility = visibility;
                        container.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
                        this.classList.add('selected');
                    };
                });
                return container;
            }
        });
		L.Control.BusStopArrival = L.Control.extend({
            options: {
                position: 'bottomleft'
            },
            onAdd: function(mapCtrl) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                const button = L.DomUtil.create('button', 'leaflet-control-custom', container);
				button.id = 'busStopArrivalButton'; // ★★★ この行を追加 ★★★
                button.innerHTML = 'バス停到着';
                button.style.fontWeight = 'bold';
                
                L.DomEvent.disableClickPropagation(button);
                L.DomEvent.on(button, 'click', openArrivalModal);

                return container;
            }
        });
        map.addControl(new L.Control.BusStopArrival());
        map.addControl(new L.Control.Visibility());

        L.Control.RoadCondition = L.Control.extend({
            options: { position: 'topleft' },
            onAdd: function(mapCtrl) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control-road-condition');
                L.DomEvent.disableClickPropagation(container);
                const conditions = ['乾燥', '湿潤', '凍結', '積雪'];
                conditions.forEach(condition => {
                    const button = L.DomUtil.create('button', '', container);
                    button.innerHTML = condition;
                    button.onclick = function() {
                        selectedRoadCondition = condition;
                        container.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
                        this.classList.add('selected');
                    };
                });
                return container;
            }
        });
        map.addControl(new L.Control.RoadCondition());


        L.Control.MagnifierToggle = L.Control.extend({
            options: {
                position: 'topleft'
            },
            onAdd: function (map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                this.link = L.DomUtil.create('a', 'leaflet-control-magnifier-toggle', container);
                this.link.href = '#';
                this.link.title = '虫眼鏡 ON/OFF';
                this.link.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" style="width: 20px; height: 20px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;

                L.DomEvent.on(this.link, 'click', L.DomEvent.stop);
                L.DomEvent.on(this.link, 'click', this._toggle, this);

                return container;
            },
            _toggle: function () {
                if (magnifyingGlass && map.hasLayer(magnifyingGlass)) {
                    map.removeLayer(magnifyingGlass);
                    magnifyingGlass = null;
                    L.DomUtil.removeClass(this.link, 'active');
                } else {
                    const baseOptions = currentBaseLayer.options;
                    magnifyingGlass = L.magnifyingGlass({
                        zoomOffset: 3,
                        layers: [ L.tileLayer(currentBaseLayer._url, baseOptions) ]
                    }).addTo(map);
                    L.DomUtil.addClass(this.link, 'active');
                }
            }
        });
        map.addControl(new L.Control.MagnifierToggle());
        
        L.control.zoom({ position: 'topleft' }).addTo(map);

        L.Control.geocoder({
            position: 'bottomleft',
            placeholder: '市町村などを検索...',
            defaultMarkGeocode: false
        }).on('markgeocode', function(e) {
            map.fitBounds(e.geocode.bbox);
        }).addTo(map);
        
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                pos => map.setView([pos.coords.latitude, pos.coords.longitude], 16),
                err => {
                    console.warn(`ERROR(${err.code}): ${err.message}`);
                    map.setView([35.1709, 136.8815], 13); 
                }
            );
        } else {
            map.setView([35.1709, 136.8815], 13); 
        }

        markerLayerGroup.addTo(map);
        drawnItems.addTo(map);
        // START: Polyline color palette control
        L.Control.ColorPalette = L.Control.extend({
            options: { position: 'topleft' },
            onAdd: function(mapCtrl) {
                const container = L.DomUtil.create('div', 'leaflet-control-color-palette');
                L.DomEvent.disableClickPropagation(container);
                polylineColors.forEach(color => {
                    const swatch = L.DomUtil.create('div', 'color-swatch', container);
                    swatch.style.backgroundColor = color;
                    if (color === currentPolylineColor) swatch.classList.add('selected');
                    swatch.onclick = function() {
                        currentPolylineColor = color;
                        container.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                        this.classList.add('selected');
                        if (drawControl) {
                             drawControl.setDrawingOptions({
                                polyline: { shapeOptions: { ...globalPolylineStyles, color: currentPolylineColor } }
                            });
                        }
                    };
                });
                return container;
            }
        });
        map.addControl(new L.Control.ColorPalette());
        // END: Polyline color palette control

        drawControl = new L.Control.Draw({ // constを削除してグローバル変数に代入
            draw: { 
                polygon: { allowIntersection: false, shapeOptions: globalPolygonStyles }, 
                polyline: { shapeOptions: { ...globalPolylineStyles, color: currentPolylineColor } }, // 初期色を設定
                marker: false, 
                circle: false, 
                rectangle: false, 
                circlemarker: false 
            },
            edit: { featureGroup: drawnItems, remove: true }
        });
        map.addControl(drawControl);

        L.Control.StreetParkingAvoidance = L.Control.extend({
            onAdd: function(mapCtrl) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
                L.DomEvent.disableClickPropagation(container);
                const mainButton = L.DomUtil.create('button', '', container);
                mainButton.innerHTML = '路駐回避成功';
                mainButton.id = 'streetParkingMainButton';
                const subButtonsContainer = L.DomUtil.create('div', 'street-parking-avoidance-sub-buttons', container);
                subButtonsContainer.id = 'streetParkingSubButtons';
                const cancelButton = L.DomUtil.create('button', 'cancel', subButtonsContainer);
                cancelButton.innerHTML = 'キャンセル';

                L.DomEvent.on(mainButton, 'click', function (e) {
                    L.DomEvent.stopPropagation(e);
                    if (!validatePrerequisites()) return; // ★★★ 関数名を修正 ★★★
                    if (isWaitingForStreetParkingDoubleClick) {
                        cancelStreetParkingDoubleClick();
                        return;
                    }
                    if (activeFavoriteSlotToLog) { 
                        resetActiveFavoriteLogging();
                    }
                    streetParkingAvoidanceRecordTime = getCurrentJSTString();
                    isWaitingForStreetParkingDoubleClick = true;
                    subButtonsContainer.style.display = 'block';
                    mainButton.innerHTML = '記録位置指定中...';
                    mainButton.classList.add('active'); 
                    console.log('路駐回避成功: 地図をダブルクリックして記録位置を指定してください。');
                });
                L.DomEvent.on(cancelButton, 'click', function (e) {
                    L.DomEvent.stopPropagation(e);
                    cancelStreetParkingDoubleClick();
                });
                return container;
            },
            onRemove: function(mapCtrl) {}
        });
        new L.Control.StreetParkingAvoidance({ position: 'topright' }).addTo(map);
   L.Control.FavoriteButtons = L.Control.extend({
            onAdd: function(mapCtrl) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control-favorites');
                L.DomEvent.disableClickPropagation(container);
                return container;
            },
            onRemove: function(mapCtrl) {}
        });
        favoriteButtonsControl = new L.Control.FavoriteButtons({ position: 'topright' });
        map.addControl(favoriteButtonsControl);

        map.on("draw:created", function (e) {
            const type = e.layerType;
            const layer = e.layer;
            
            layer.feature = layer.toGeoJSON();
            layer.feature.type = 'Feature'; 
            if (!layer.feature.properties) {
                layer.feature.properties = {}; 
            }
            
            let shapeOptions;
            if (type === 'polygon') {
                shapeOptions = { ...globalPolygonStyles };
            } else if (type === 'polyline') {
                // 選択されている色を適用する
                shapeOptions = { ...globalPolylineStyles, color: currentPolylineColor };
            }
            
            if (shapeOptions) {
                layer.setStyle(shapeOptions);
                Object.assign(layer.feature.properties, shapeOptions);
            }

            if (type === 'polygon') {
                pendingAreaLayer = layer;
                openAreaInfoModal();
            } else if (type === 'polyline') {
                layer.feature.properties.name = "（線）";
                drawnItems.addLayer(layer);
            }
        });

        map.on('draw:editstart', function(e) {
            const bulkStyleButton = L.DomUtil.create('a', 'leaflet-draw-actions-btn', document.querySelector('.leaflet-draw-actions a').parentElement);
            bulkStyleButton.innerHTML = '一括スタイル変更';
            bulkStyleButton.href = '#';
            bulkStyleButton.title = '表示されている全ての線・エリアのスタイルを変更します';
            L.DomEvent.on(bulkStyleButton, 'click', L.DomEvent.stop).on(bulkStyleButton, 'click', openGlobalStyleEditor);
            
            drawnItems.eachLayer(layer => attachInfoEditor(layer));
        });

        map.on('draw:editstop', function(e) {
             document.querySelector('.leaflet-draw-actions-btn')?.remove();
             drawnItems.eachLayer(layer => layer.off('click'));
        });
        map.on('draw:edited', function (e) {
            e.layers.eachLayer(function (layer) {
                if (!(layer instanceof L.Polygon) && !(layer instanceof L.Polyline)) return;
                
                if (layer.feature && layer.feature.properties) {
                    const props = layer.feature.properties;

                    layer.setStyle({
                        color: props.color,
                        weight: props.weight,
                        opacity: props.opacity,
                        fillColor: props.fillColor,
                        fillOpacity: props.fillOpacity
                    });

                    if (props.name) {
                        const tooltip = labelMap.get(layer);
                        
                        let anchorLatLng;
                        try {
                            if (layer.getBounds && layer.getBounds().isValid()) {
                                const bounds = layer.getBounds();
                                anchorLatLng = L.latLng(bounds.getCenter().lat, bounds.getEast());
                            } else {
                                anchorLatLng = layer.getCenter ? layer.getCenter() : null;
                            }
                        } catch(err) {
                            console.warn("Could not get anchor for tooltip.", err);
                            anchorLatLng = layer.getCenter ? layer.getCenter() : null;
                        }

                        if(tooltip && anchorLatLng) {
                            tooltip.setLatLng(anchorLatLng);
                        } else if (anchorLatLng) {
                            const newTooltip = L.tooltip({
                                permanent: true,
                                direction: 'right',
                                offset: [15, 0],
                                className: 'speech-bubble-tooltip'
                            }).setContent(props.name);
                            labelMap.set(layer, newTooltip);
                            layer.bindTooltip(newTooltip).setTooltipContent(props.name);
                        }
                        
                        if (showLabels) {
                            layer.openTooltip();
                        }
                    }
                }
            });
        });

        map.on('baselayerchange', function (e) {
            currentBaseLayer = e.layer;
            if (magnifyingGlass && map.hasLayer(magnifyingGlass)) {
                map.removeLayer(magnifyingGlass);
                magnifyingGlass = L.magnifyingGlass({
                    zoomOffset: 3,
                    layers: [ L.tileLayer(currentBaseLayer._url, currentBaseLayer.options) ]
                }).addTo(map);
            }
        });
        // START: Show/hide color palette on draw start/stop
        map.on('draw:drawstart', function (e) {
            if (e.layerType === 'polyline') {
                const palette = document.querySelector('.leaflet-control-color-palette');
                if (palette) palette.style.display = 'flex';
            }
        });

        map.on('draw:drawstop', function (e) {
            const palette = document.querySelector('.leaflet-control-color-palette');
            if (palette) palette.style.display = 'none';
        });
        // END: Show/hide color palette
        map.on("dblclick", function (e) {
            const latlng = e.latlng;
            if (activeFavoriteSlotToLog) {
                logFavorite(activeFavoriteSlotToLog, latlng);
            } else if (isWaitingForStreetParkingDoubleClick) {
                const areaInfo = getAreaInfoFromPoint(latlng);
                const recordData = {
                    recordTime: streetParkingAvoidanceRecordTime,
                    lat: latlng.lat, lng: latlng.lng,
                    direction: currentDirection,
                    project: document.getElementById("projectName").value.trim(),
                    trip: document.getElementById("tripNumber").value.trim(),
                    areaInfo: areaInfo, 
                };
                sendLogForStreetParking(recordData);
                cancelStreetParkingDoubleClick();
            } else if (document.getElementById('nonInterventionModal').style.display === 'flex') {
                pendingLog = { latlng: latlng, type: '非介入記録（位置指定）', time: getCurrentJSTString() };
                console.log("非介入記録の位置が設定されました。モーダルで「記録する」を押してください。");
                const latLngDisplay = document.getElementById('nonInterventionSelectedLocation');
                if (latLngDisplay) {
                    latLngDisplay.textContent = `記録位置: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;
                }
            } else {
                 if (!validatePrerequisites()) return;
                 openModal(latlng, "ダブルクリック");
            }
        });

        let lastTap = 0;
        map.getContainer().addEventListener("touchend", function (e) {
            const now = new Date().getTime();
            const target = e.target;
            if (!target.closest('.leaflet-control-container') &&
                !target.closest('.leaflet-popup-pane') &&
                !target.closest('.modal-overlay')) {
                 if (now - lastTap < 400) { 
                     const touch = e.changedTouches[0];
                     const latlng = map.containerPointToLatLng(L.point(touch.clientX, touch.clientY));
                     
                     if (activeFavoriteSlotToLog) {
                         logFavorite(activeFavoriteSlotToLog, latlng);
                         e.preventDefault();
                     } else if (isWaitingForStreetParkingDoubleClick) {
                         const areaInfo = getAreaInfoFromPoint(latlng);
                         const recordData = {
                             recordTime: streetParkingAvoidanceRecordTime,
                             lat: latlng.lat, lng: latlng.lng,
                             direction: currentDirection,
                             project: document.getElementById("projectName").value.trim(),
                             trip: document.getElementById("tripNumber").value.trim(),
                             areaInfo: areaInfo,
                         };
                         sendLogForStreetParking(recordData);
                         cancelStreetParkingDoubleClick();
                         e.preventDefault();
                     } else if (document.getElementById('nonInterventionModal').style.display === 'flex') {
                         pendingLog = { latlng: latlng, type: '非介入記録（位置指定）', time: getCurrentJSTString() };
                         console.log("非介入記録の位置が設定されました。モーダルで「記録する」を押してください。");
                         const latLngDisplay = document.getElementById('nonInterventionSelectedLocation');
                         if (latLngDisplay) {
                             latLngDisplay.textContent = `記録位置: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;
                         }
                         e.preventDefault();
                     } else {
                         if (!validatePrerequisites()) return;
                         openModal(latlng, "ダブルタップ");
                         e.preventDefault();
                     }
                 }
                 lastTap = now;
            }
        });
        
        map.on('click', () => {
             document.querySelectorAll('.busstop-sub-buttons').forEach(s => s.style.display = 'none');
        });

        toggleLabels(true);
        loadBusStops();
        loadFavorites();
    }
    
    function cancelStreetParkingDoubleClick() {
        isWaitingForStreetParkingDoubleClick = false;
        streetParkingAvoidanceRecordTime = null;
        const subButtonsContainer = document.getElementById('streetParkingSubButtons');
        if (subButtonsContainer) subButtonsContainer.style.display = 'none';
        const mainButton = document.getElementById('streetParkingMainButton');
        if (mainButton) {
            mainButton.innerHTML = '路駐回避成功';
            mainButton.classList.remove('active');
        }
    }

    function logCurrentGPS() {
        if (!validatePrerequisites()) return;
        
        if (isWaitingForStreetParkingDoubleClick) {
            alert("路駐回避成功の記録位置指定中です。先に記録を完了するかキャンセルしてください。");
            return;
        }
         if (activeFavoriteSlotToLog) {
            alert("お気に入り記録待機中です。先に地図をクリックするか、別のお気に入りを選択/キャンセルしてください。");
            return;
        }

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const latlng = L.latLng(position.coords.latitude, position.coords.longitude);
                    map.setView(latlng, map.getZoom() < 16 ? 16 : map.getZoom());
                    openModal(latlng, "GPS記録");
                },
                (error) => {
                    console.error("GPS位置情報の取得に失敗しました。", error);
                    alert("GPS位置情報の取得に失敗しました。\nエラーコード: " + error.code + "\nメッセージ: " + error.message);
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        } else {
            alert("お使いのブラウザはGPS機能に対応していません。");
        }
    }

    function setDirection(dir) {
        currentDirection = dir;
        document.querySelectorAll('.direction-button').forEach(btn => {
            btn.classList.remove('selected');
            btn.classList.remove('warning');
        });
        const selectedBtn = Array.from(document.querySelectorAll('.direction-button')).find(btn => btn.textContent === dir);
        if (selectedBtn) {
            selectedBtn.classList.add('selected');
        }
    }

    function validatePrerequisites() {
        // 先にすべての警告表示をクリア
        document.querySelectorAll('.direction-button').forEach(btn => btn.classList.remove('warning'));
        document.getElementById('tripNumber').classList.remove('warning');
        document.querySelector('.leaflet-control-weather')?.classList.remove('warning');
        document.querySelector('.leaflet-control-visibility')?.classList.remove('warning');
        document.querySelector('.leaflet-control-road-condition')?.classList.remove('warning');

        if (!currentDirection) {
            alert("「往路」または「復路」を選択してください。");
            document.querySelectorAll('.direction-button').forEach(btn => btn.classList.add('warning'));
            return false;
        }
        if (!document.getElementById("tripNumber").value) {
            alert("便数を選択してください。");
            document.getElementById('tripNumber').classList.add('warning');
            return false;
        }
        if (!selectedWeather) {
            alert("天候を選択してください。");
            document.querySelector('.leaflet-control-weather')?.classList.add('warning');
            return false;
        }
        if (!selectedVisibility) {
            alert("視界を選択してください。");
            document.querySelector('.leaflet-control-visibility')?.classList.add('warning');
            return false;
        }
        if (!selectedRoadCondition) {
            alert("路面状況を選択してください。");
            document.querySelector('.leaflet-control-road-condition')?.classList.add('warning');
            return false;
        }

        // 全てのチェックを通過
        return true;
    }

    function getAreaInfoFromPoint(latlng) {
        const pt = turf.point([latlng.lng, latlng.lat]);
        for (const layer of drawnItems.getLayers()) {
            if (layer.feature && layer.feature.geometry && layer.feature.geometry.type === 'Polygon' && turf.booleanPointInPolygon(pt, layer.toGeoJSON())) {
                return layer.feature.properties || null;
            }
        }
        return null;
    }
    
    function getDirectionalAreaInfo(areaInfo, direction) {
        if (!areaInfo) {
            return { shape1: "", shape2: "", shape3: "", l4_status: "", mlit_extra: "" };
        }
        const targetDirection = direction || currentDirection; // Use passed direction, fallback to global
        const directionInfo = (targetDirection === '復路' && areaInfo.inbound) ? areaInfo.inbound : areaInfo.outbound;
        if (!directionInfo) {
             return { shape1: "", shape2: "", shape3: "", l4_status: "", mlit_extra: "" };
        }
        return {
            shape1: directionInfo.shape1 ? directionInfo.shape1.join(', ') : "",
            shape2: directionInfo.shape2 ? directionInfo.shape2.join(', ') : "",
            shape3: directionInfo.shape3 ? directionInfo.shape3.join(', ') : "",
            l4_status: directionInfo.l4_status ? directionInfo.l4_status.join(', ') : "",
            mlit_extra: directionInfo.mlit_extra ? directionInfo.mlit_extra.join(', ') : ""
        };
    }

    function getShapePresence(shape1String) {
        const shape1 = shape1String || "";
        return {
            "信号有無": shape1.includes('信号') ? '有' : '無',
            "横断歩道有無": shape1.includes('横断歩道') ? '有' : '無',
            "バス停有無": shape1.includes('バス停') ? '有' : '無',
            "歩者分離有無": shape1.includes('歩者分離されている') ? '有' : '無'
        };
    }
    function toggleLabels(forceUpdate = false) {
        if (!forceUpdate) showLabels = !showLabels;
        const button = document.getElementById('toggleLabelsButton');
        if (showLabels) {
            button.classList.remove('labels-hidden');
            button.title = 'エリア名を非表示にする';
        } else {
            button.classList.add('labels-hidden');
            button.title = 'エリア名を表示する';
        }
        drawnItems.eachLayer(layer => {
            const tooltip = labelMap.get(layer);
            if (tooltip) {
                if (showLabels) {
                    if (!layer.getTooltip()) layer.bindTooltip(tooltip);
                    layer.openTooltip();
                } else {
                    if (layer.getTooltip()) layer.closeTooltip();
                }
            }
        });
    }

    function exportGeoJSON() {
        const geojson = drawnItems.toGeoJSON();
        if (!geojson || !geojson.features || !geojson.features.length) {
             console.warn("保存するエリアがありません。");
             return;
        }

        const fileNameInput = document.getElementById('geoFileName');
        let fileName = fileNameInput.value.trim();

        if (!fileName) {
            fileNameInput.style.border = '2px solid red';
            fileNameInput.placeholder = "ファイル名を入力してください";
            setTimeout(() => {
                fileNameInput.style.border = '';
                fileNameInput.placeholder = "保存ファイル名";
            }, 2500);
            return;
        }

        if (!fileName.toLowerCase().endsWith('.json')) {
            fileName += '.json';
        }

        const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    function openLoadChoiceModal() {
        showModal('loadChoiceModal');
    }
    
    function importJsonFile(event) {
        closeModal('loadChoiceModal');
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const geojson = JSON.parse(e.target.result);
                if (!geojson || !geojson.type || !geojson.features) {
                    throw new Error("Invalid GeoJSON object.");
                }
                importGeoJSONFromData(geojson);
            } catch (err) {
                alert("JSONファイルの読み込みに失敗しました: " + err.message);
                console.error(err);
            }
        };
        reader.readAsText(file);
        event.target.value = ''; 
    }

    function importKmlKmzFile(event) {
        closeModal('loadChoiceModal');
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        const fileName = file.name.toLowerCase();

        const processKmlText = (kmlText) => {
            try {
                if (typeof toGeoJSON === 'undefined') {
                    throw new Error('KML変換ライブラリが読み込まれていません。');
                }
                const kml = new DOMParser().parseFromString(kmlText, 'text/xml');
                const parserError = kml.querySelector('parsererror');
                if (parserError) {
                    console.error('KML Parsing Error:', parserError.textContent);
                    throw new Error('KMLファイルの解析に失敗しました。');
                }
                const geojson = toGeoJSON.kml(kml);
                if (!geojson.features || geojson.features.length === 0) {
                    throw new Error('KMLファイル内に有効なジオメトリデータが見つかりませんでした。');
                }
                importGeoJSONFromData(geojson);
            } catch (err) {
                alert(`KMLデータの処理中にエラーが発生しました: ${err.message}`);
                console.error(err);
            }
        };

        if (fileName.endsWith('.kmz')) {
            reader.onload = function(e) {
                if (typeof JSZip === 'undefined') {
                    alert('KMZ読み込みライブラリ(JSZip)が読み込まれていません。');
                    return;
                }
                JSZip.loadAsync(e.target.result)
                    .then(zip => {
                        const kmlFile = Object.keys(zip.files).find(name => name.toLowerCase().endsWith('.kml'));
                        if (kmlFile) {
                            return zip.file(kmlFile).async("string");
                        }
                        throw new Error("KMZファイル内にKMLファイル(.kml)が見つかりませんでした。");
                    })
                    .then(processKmlText)
                    .catch(err => {
                        alert(`KMZファイルの処理に失敗しました: ${err.message}`);
                        console.error(err);
                    });
            };
            reader.readAsArrayBuffer(file);
        } else if (fileName.endsWith('.kml')) {
            reader.onload = function (e) {
                processKmlText(e.target.result);
            };
            reader.readAsText(file);
        }
        event.target.value = '';
    }

    function importGeoJSONFromData(geojson) {
        drawnItems.clearLayers();
        labelMap.clear();
        try {
            L.geoJSON(geojson, {
                style: function(feature) {
                    const properties = feature.properties || {};
                    const geomType = feature.geometry.type;

                    let style = {};
                    if (geomType === 'Polygon' || geomType === 'MultiPolygon') {
                        style = { ...globalPolygonStyles };
                    } else if (geomType === 'LineString' || geomType === 'MultiLineString') {
                        style = { ...globalPolylineStyles };
                    }
                    
                    for (const key in style) {
                        if (properties[key] !== undefined) {
                            style[key] = properties[key];
                        }
                    }
                    return style;
                },
                onEachFeature: (feature, layer) => {
                    const geomType = feature.geometry?.type;
                     if (!geomType || !['Polygon', 'MultiPolygon', 'LineString', 'MultiLineString'].includes(geomType)) {
                        return;
                    }

                    if (layer.feature.properties && layer.feature.properties.name) {
                        const tooltip = L.tooltip({
                            permanent: true,
                            direction: 'right',
                            offset: [15, 0],
                            className: 'speech-bubble-tooltip'
                        }).setContent(layer.feature.properties.name);

                        let anchorLatLng;
                        try {
                            if (layer.getBounds && layer.getBounds().isValid()) {
                                const bounds = layer.getBounds();
                                anchorLatLng = L.latLng(bounds.getCenter().lat, bounds.getEast());
                            } else {
                                anchorLatLng = layer.getCenter ? layer.getCenter() : null;
                            }
                        } catch(err) {
                            anchorLatLng = layer.getCenter ? layer.getCenter() : null;
                        }
                        
                        if (anchorLatLng) {
                            tooltip.setLatLng(anchorLatLng);
                            labelMap.set(layer, tooltip);
                            layer.bindTooltip(tooltip);
                            if (showLabels) layer.openTooltip();
                        }
                    }
                    drawnItems.addLayer(layer);
                }
            });

            if (drawnItems.getLayers().length > 0) {
                const bounds = drawnItems.getBounds();
                if (bounds.isValid()) map.fitBounds(bounds, { padding: [20, 20] });
            }
        } catch (e) {
            alert("GeoJSONデータの処理中にエラーが発生しました: " + e.message);
            console.error("GeoJSON処理エラー:", e);
        }
    }
    function openModal(latlng, type) {
        if (isWaitingForStreetParkingDoubleClick) {
            console.log("路駐回避成功の記録位置指定中です。キャンセルして新しい記録を開始しますか？");
            return;
        }
         if (activeFavoriteSlotToLog) { 
            resetActiveFavoriteLogging();
        }
        
        editingPinData = null; 
        buttonStates = {};

        const jst = getCurrentJSTString();
        pendingLog = { latlng, type, time: jst };
        
        document.getElementById('interventionRecordTime').value = getCurrentJSTString('datetime-local');
        
        // ★★★ チェックボックスをリセットする処理を追加 ★★★
        if (document.getElementById('isIntersectionNearby')) {
            document.getElementById('isIntersectionNearby').checked = false;
        }
        
        createDynamicFields('dynamicFields', fields); 
        document.querySelectorAll('#customModal .position-grid div[data-pos].selected').forEach(e => e.classList.remove('selected'));
        document.getElementById('freeMemo').value = "";
        
        document.querySelector('#customModalTitle').textContent = '介入記録を入力してください';
		showModal("customModal");
        
        resetDetailsTab();
    }
   
    function showModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'flex';
            const contentBox = modal.querySelector('.modal-content-box');
            if (contentBox) {
                contentBox.scrollTop = 0;
            }
        }
    }

    function closeModal(modalId) {
    const modalElement = document.getElementById(modalId);
    if (modalElement) modalElement.style.display = "none";
    
    // editingPinData = null; // この行を削除
    
    if (modalElement) {
        modalElement.querySelectorAll('.ok-button.processing').forEach(btn => {
            let originalText = btn.dataset.originalText || "OK";
            resetButtonState(btn, originalText);
        });
    }
}

    function openNonInterventionModal() {
        if (isWaitingForStreetParkingDoubleClick) {
            console.log("路駐回避成功の記録位置指定中です。先に記録を完了するかキャンセルしてください。");
            return;
        }
         if (activeFavoriteSlotToLog) { 
            resetActiveFavoriteLogging();
        }
        
        if (!pendingLog) {
            pendingLog = {};
        }
        
        closeModal('customModal'); 
        
        try {
            document.getElementById('nonInterventionMemo').value = '';
            document.getElementById('nonInterventionHiyari').checked = false;
            document.getElementById('nonInterventionMemoOnly').checked = false;
            const signalRadios = document.getElementsByName('signalDetection');
            for(let i=0; i < signalRadios.length; i++) {
                signalRadios[i].checked = false;
            }
            document.getElementById('signalOtherMemo').value = '';
            document.getElementById('signalOtherMemo').style.display = 'none';

            const latLngDisplay = document.getElementById('nonInterventionSelectedLocation');
            if (latLngDisplay) {
                if (pendingLog && pendingLog.latlng) {
                    latLngDisplay.textContent = `記録位置: ${pendingLog.latlng.lat.toFixed(6)}, ${pendingLog.lng.toFixed(6)} (介入記録から引継ぎ)`;
                } else {
                    latLngDisplay.textContent = '記録位置: 未指定 (地図をダブルクリック/タップで指定、または記録時にGPS取得)';
                }
            }
        } catch(e) {
            console.error("非介入モーダルの初期化中にエラーが発生しました:", e);
        }
        
        showModal('nonInterventionModal');
    }
	
    function closeNonInterventionModal(returnToMain = false) { 
        closeModal('nonInterventionModal');
        if (returnToMain) {
            showModal('customModal');
        }
    }

    function closeMinorReasonModalAndReset() {
        closeModal('minorReasonModal');
    }


    function toggleSignalOtherMemo(show) {
        document.getElementById('signalOtherMemo').style.display = show ? 'inline-block' : 'none';
        if (!show) {
            document.getElementById('signalOtherMemo').value = '';
        }
    }

    function toggleSelect(btn) {
        btn.classList.toggle("selected");
    }


    function getSelectedTexts(containerId) {
        return Array.from(document.querySelectorAll(`#${containerId} button.selected`)).map(btn => btn.textContent).join(", ");
    }
	function showTab(tabName, clickedButton) {
        // クリックされたボタンが所属するナビゲーションエリアを取得
        const nav = clickedButton.closest('.tab-nav');
        // そのナビゲーションの直後にあるコンテンツエリアを取得
        const content = nav.nextElementSibling;

        if (!nav || !content) return;

        // ★★★ このタブセクションの中だけで、全ての選択状態を解除 ★★★
        nav.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));
        content.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));

        // クリックされたタブとその内容だけを選択状態にする
        clickedButton.classList.add('active');
        const targetPane = content.querySelector(`#tab-pane-${tabName}`);
        if (targetPane) {
            targetPane.classList.add('active');
        }
    }

	/**
	 * ★★★ 新規追加 ★★★
	 * 「状況詳細」のタブを初期状態（「自車の状態」を選択）に戻す関数
	 */
	function resetDetailsTab() {
		const nav = document.getElementById('details-tab-nav');
		const content = document.getElementById('details-tab-content');

		if (!nav || !content) return;

		// 全てのタブと表示エリアから 'active' クラスを一旦削除
		nav.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));
		content.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));

		// 最初のタブ（自車の状態）とその表示エリアに 'active' クラスを再設定
		const defaultButton = nav.querySelector('button');
		const defaultPane = content.querySelector('#tab-pane-ego');

		if (defaultButton) defaultButton.classList.add('active');
		if (defaultPane) defaultPane.classList.add('active');
	}

    const fields = [
        { id: 'reason', label: '介入事由', type: 'hierarchical' },
        { id: 'factor', label: '要因', options: ['歩行者', '自転車', 'バイク', '乗用車', '中型車（大型車）', '大型車', 'その他'] },
        { id: 'ego', label: '自車状態', options: ['直進', '右折', '左折', '停止', '合流', '出発', 'その他'] },
        { id: 'target', label: '相手の動き', options: ['直進', '右折', '左折', '停止', '直進（減速）', '直進（加速）', '合流', '出発', '横断', '直進（回避）', '直進（カーブ走行）', '合流（追い越し）', '合流（割込）', '直進（急減速）', '直進（急加速）', '停止（譲る）'] },
		{ id: 'operation', label: '介入操作', options: ['ステアリング操作', 'アクセル操作', 'ブレーキ操作', '非常停止ボタン操作', 'その他'] },
    ];
    function createDynamicFields(containerId, fieldList) {
    const isMainModal = containerId === 'dynamicFields';

    if (isMainModal) {
        // メインモーダルのタブ、介入操作、介入事由のコンテナをクリア
        document.querySelectorAll('#tab-pane-factor, #tab-pane-ego, #tab-pane-target, #operation-container, #reason-major-buttons').forEach(el => el.innerHTML = '');
        if (currentlySelectedMajorButton) {
            currentlySelectedMajorButton.classList.remove('selected-major');
            currentlySelectedMajorButton = null;
        }
        document.getElementById('selectedReasonDisplay').textContent = editingPinData && buttonStates.reason && buttonStates.reason.major 
            ? `${buttonStates.reason.major}: ${buttonStates.reason.minors.join(' : ')}`
            : "未選択";
    } else {
        const container = document.getElementById(containerId);
        if(container) container.innerHTML = '';
    }

    fieldList.forEach(field => {
        if (isMainModal) {
            if (field.id === 'reason') {
                createReasonField('reason-major-buttons');
            // ★★★ タブに入れる項目を変更 ★★★
            } else if (['factor', 'ego', 'target'].includes(field.id)) {
                createOptionField(field, `tab-pane-${field.id}`, 'dynamicFields');
            // ★★★ 「介入操作」を別のコンテナに入れるロジックを追加 ★★★
            } else if (field.id === 'operation') {
                createOptionField(field, 'operation-container', 'dynamicFields');
            }
        } else { // お気に入りモーダルの場合
            const container = document.getElementById(containerId);
            if(container) {
                const fieldDiv = document.createElement('div');
                fieldDiv.classList.add('modal-field');
                const labelP = document.createElement('p');
                labelP.innerHTML = `<strong>${field.label}</strong>`;
                fieldDiv.appendChild(labelP);
                container.appendChild(fieldDiv);
                createOptionField(field, fieldDiv, 'favoriteDynamicFields');
            }
        }
    });
}
function showReasonTab(tabId, clickedButton) {
    // 全てのタブ（ボタン）からactiveクラスを削除
    document.querySelectorAll('#reason-tab-nav .tab-button').forEach(button => button.classList.remove('active'));
    // 全てのタブの中身（ペイン）を非表示に
    document.querySelectorAll('#reason-tab-content .tab-pane').forEach(pane => pane.style.display = 'none');

    // クリックされたタブをアクティブに
    clickedButton.classList.add('active');
    // 対応する中身を表示
    document.getElementById(tabId).style.display = 'block';
}
function createReasonField(containerId) {
    // この関数はもう containerId を使わないが、互換性のために残す
    const navContainer = document.getElementById('reason-tab-nav');
    const contentContainer = document.getElementById('reason-tab-content');
    if (!navContainer || !contentContainer) return;

    // コンテナをクリア
    navContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    const allMajorReasonsFromData = { ...interventionReasonData, ...userAddedReasons };
    const processedReasons = new Set(); // ★どの理由を処理したか記録するためのSet

    const createButton = (majorReason) => {
        const btn = document.createElement('button');
        btn.textContent = majorReason;
        if (editingPinData && buttonStates.reason && buttonStates.reason.major === majorReason) {
            btn.classList.add('selected-major');
            currentlySelectedMajorButton = btn;
        }
        btn.onclick = (event) => {
            if (currentlySelectedMajorButton) {
                currentlySelectedMajorButton.classList.remove('selected-major');
            }
            event.target.classList.add('selected-major');
            currentlySelectedMajorButton = event.target;
            openMinorReasonModal(majorReason);
        };
        return btn;
    };

    // 1. 「全て」タブを生成
    const allTabButton = document.createElement('button');
    allTabButton.className = 'tab-button active';
    allTabButton.textContent = '全て';
    allTabButton.onclick = function() { showReasonTab('reason-pane-all', this); };
    navContainer.appendChild(allTabButton);

    const allPane = document.createElement('div');
    allPane.id = 'reason-pane-all';
    allPane.className = 'tab-pane multi-select active';
    allPane.style.display = 'block';
    Object.keys(allMajorReasonsFromData).sort((a,b) => a.localeCompare(b, 'ja')).forEach(reason => {
        allPane.appendChild(createButton(reason));
    });
    contentContainer.appendChild(allPane);

    // 2. カテゴリごとのタブを生成
    for (const categoryName in majorReasonCategories) {
        const categoryTabId = `reason-pane-${categoryName.replace(/\s/g, '-')}`;
        
        const categoryTabButton = document.createElement('button');
        categoryTabButton.className = 'tab-button';
        categoryTabButton.textContent = categoryName;
        categoryTabButton.onclick = function() { showReasonTab(categoryTabId, this); };

        const categoryPane = document.createElement('div');
        categoryPane.id = categoryTabId;
        categoryPane.className = 'tab-pane multi-select';
        categoryPane.style.display = 'none';

        majorReasonCategories[categoryName].forEach(reason => {
            if (allMajorReasonsFromData[reason]) {
                categoryPane.appendChild(createButton(reason));
                processedReasons.add(reason); // ★処理済みの理由として記録
            }
        });

        // ボタンが1つでもあればタブを追加
        if(categoryPane.hasChildNodes()){
            navContainer.appendChild(categoryTabButton);
            contentContainer.appendChild(categoryPane);
        }
    }

    // ★★★ ここからカスタムタブを生成するロジックを追加 ★★★
    // 3. いずれのカテゴリにも属さない項目（カスタム追加された項目）を処理
    const uncategorizedReasons = Object.keys(allMajorReasonsFromData)
        .filter(reason => !processedReasons.has(reason));

    if (uncategorizedReasons.length > 0) {
        const customTabId = 'reason-pane-custom';
        const customTabButton = document.createElement('button');
        customTabButton.className = 'tab-button';
        customTabButton.textContent = 'その他';
        customTabButton.onclick = function() { showReasonTab(customTabId, this); };
        navContainer.appendChild(customTabButton);

        const customPane = document.createElement('div');
        customPane.id = customTabId;
        customPane.className = 'tab-pane multi-select';
        customPane.style.display = 'none';

        uncategorizedReasons.sort((a, b) => a.localeCompare(b, 'ja')).forEach(reason => {
            customPane.appendChild(createButton(reason));
        });
        contentContainer.appendChild(customPane);
    }
    // ★★★ ここまで追加 ★★★
}

function createOptionField(field, container, prefix) {
    const containerEl = (typeof container === 'string') ? document.getElementById(container) : container;
    if (!containerEl) return;

    const isFavoriteModal = prefix === 'favoriteDynamicFields';
    let targetContainer = containerEl;

    if (!isFavoriteModal) {
        const controlsDiv = document.createElement('div');
        controlsDiv.classList.add('modal-field-controls');
        containerEl.appendChild(controlsDiv);
        targetContainer = controlsDiv;
    }
    
    const multiSelectDiv = document.createElement('div');
    multiSelectDiv.classList.add('multi-select');
    multiSelectDiv.id = `${prefix}-${field.id}-buttons`;

    const defaultOptions = field.options || [];
    const customOptions = JSON.parse(localStorage.getItem(`${field.id}-custom`) || '[]');
    const allOptions = [...new Set([...defaultOptions, ...customOptions])];

    allOptions.forEach(optionText => {
        const btn = document.createElement('button');
        btn.textContent = optionText;
        btn.onclick = () => toggleSelect(btn);
        if (editingPinData) {
            const pinDataKey = field.label;
            if (editingPinData[pinDataKey] && editingPinData[pinDataKey].split(', ').includes(optionText)) {
                btn.classList.add('selected');
            }
        }
        multiSelectDiv.appendChild(btn);
    });

    targetContainer.appendChild(multiSelectDiv);

    const inputGroupDiv = document.createElement('div');
    inputGroupDiv.classList.add('modal-input-group');
    const inputElement = document.createElement('input');
    inputElement.type = 'text';
    inputElement.id = `${prefix}-${field.id}-input`;
    inputElement.placeholder = '新しい選択肢を入力';
    const addOptionButton = document.createElement('button');
    addOptionButton.textContent = '追加';
    addOptionButton.onclick = () => addCustomOption(field.id, prefix);
    const removeButton = document.createElement('button');
    removeButton.textContent = '削除';
    removeButton.onclick = () => removeSelectedButtons(field.id, prefix);
    removeButton.style.backgroundColor = '#dc3545';
    removeButton.style.color = 'white';
    
    inputGroupDiv.appendChild(inputElement);
    inputGroupDiv.appendChild(addOptionButton);
    inputGroupDiv.appendChild(removeButton);
    targetContainer.appendChild(inputGroupDiv);
}
    function addCustomMajorReason() {
        const input = document.getElementById('newMajorReasonInput');
        const newMajorReasonName = input.value.trim();
        if (!newMajorReasonName) {
            alert("大項目名を入力してください。");
            return;
        }
        if (interventionReasonData[newMajorReasonName] || userAddedReasons[newMajorReasonName]) {
            alert(`大項目「${newMajorReasonName}」は既に存在します。`);
            return;
        }

        userAddedReasons[newMajorReasonName] = [];
        saveUserAddedReasons();
        interventionReasonData[newMajorReasonName] = []; 
        createDynamicFields('dynamicFields', fields);
        input.value = '';
        console.log("Added new major reason:", newMajorReasonName, userAddedReasons);
    }

    function removeCustomMajorReason() {
        if (!currentlySelectedMajorButton) {
            alert("削除する大項目を選択してください。\n（ボタンをクリックして青色にハイライトされている状態）");
            return;
        }

        const majorReasonNameToDelete = currentlySelectedMajorButton.textContent;

        if (!userAddedReasons.hasOwnProperty(majorReasonNameToDelete)) {
            alert(`「${majorReasonNameToDelete}」はデフォルト項目（またはカスタム追加されていない項目）のため削除できません。`);
            return;
        }

        if (confirm(`カスタム大項目「${majorReasonNameToDelete}」を削除しますか？\nこの項目に紐づく中項目もすべて削除されます。この操作は元に戻せません。`)) {
            
            const customMinorsKey = `reason-custom-${majorReasonNameToDelete}`;
            const minorsToDelete = userAddedReasons[majorReasonNameToDelete] || [];
            const savedCustomMinors = JSON.parse(localStorage.getItem(customMinorsKey) || '[]');
            const allAssociatedMinors = [...new Set([...minorsToDelete, ...savedCustomMinors])];

            allAssociatedMinors.forEach(minor => {
                delete userMlitFactorMap[minor];
            });
            saveMlitFactorMap();
            localStorage.removeItem(customMinorsKey);
            
            delete userAddedReasons[majorReasonNameToDelete];
            saveUserAddedReasons();

            loadUserAddedReasons(); 
            
            currentlySelectedMajorButton = null;
            currentMajorReason = null;
            document.getElementById('selectedReasonDisplay').textContent = "未選択";

            createDynamicFields('dynamicFields', fields);

            alert(`大項目「${majorReasonNameToDelete}」を削除しました。`);
        }
    }


    function addCustomOption(fieldId, containerPrefix) {
        const input = document.getElementById(`${containerPrefix}-${fieldId}-input`);
        const value = input.value.trim();
        if (!value) return;
        const container = document.getElementById(`${containerPrefix}-${fieldId}-buttons`);
        const exists = Array.from(container.children).some(btn => btn.textContent === value);
        if (!exists) {
            const btn = document.createElement('button');
            btn.textContent = value;
            btn.onclick = () => toggleSelect(btn);
            container.appendChild(btn);
            const saved = JSON.parse(localStorage.getItem(`${fieldId}-custom`) || '[]');
            if (!saved.includes(value)) {
                saved.push(value);
                localStorage.setItem(`${fieldId}-custom`, JSON.stringify(saved));
            }
        } else {
            alert(`「${value}」は既にボタンとして存在します。`);
        }
        input.value = "";
    }
    function addButtonFromSelect(fieldId, containerPrefix) {
        const select = document.getElementById(`${containerPrefix}-${fieldId}-select`);
        const value = select.value;
        if (!value) return;
        const container = document.getElementById(`${containerPrefix}-${fieldId}-buttons`);
        const exists = Array.from(container.children).some(btn => btn.textContent === value);
        if (!exists) {
            const btn = document.createElement('button'); btn.textContent = value; btn.onclick = () => toggleSelect(btn); container.appendChild(btn);
            const saved = JSON.parse(localStorage.getItem(`${fieldId}-custom`) || '[]');
            if (!saved.includes(value)) { saved.push(value); localStorage.setItem(`${fieldId}-custom`, JSON.stringify(saved)); }
            select.selectedIndex = 0;
        } else alert(`「${value}」は既にボタンとして存在します。`);
    }

    function loadCustomButtons(fieldId, containerPrefix) {
        const container = document.getElementById(`${containerPrefix}-${fieldId}-buttons`); if (!container) return;
        const savedButtons = JSON.parse(localStorage.getItem(`${fieldId}-custom`) || '[]'); container.innerHTML = '';
        savedButtons.forEach(text => {
             const btn = document.createElement('button'); btn.textContent = text; btn.onclick = () => toggleSelect(btn);
             container.appendChild(btn);
         });
    }

    function removeSelectedButtons(fieldId, containerPrefix) {
        const buttonsToRemove = document.querySelectorAll(`#${containerPrefix}-${fieldId}-buttons button.selected`);
        if (buttonsToRemove.length === 0) { alert("削除するボタンが選択されていません。"); return; }
        if (!confirm("選択されているカスタムボタンを削除しますか？")) return;
        buttonsToRemove.forEach(btn => {
            const text = btn.textContent;
            const savedLocalStorage = JSON.parse(localStorage.getItem(`${fieldId}-custom`) || '[]');
            const indexToRemove = savedLocalStorage.indexOf(text);
            if (indexToRemove > -1) { savedLocalStorage.splice(indexToRemove, 1); localStorage.setItem(`${fieldId}-custom`, JSON.stringify(savedLocalStorage)); }
            btn.remove();
        });
    }

    function openMinorReasonModal(majorReason) {
        currentMajorReason = majorReason;
        currentSelectedMinorReasons = [];
        if (buttonStates.reason && buttonStates.reason.major === majorReason && buttonStates.reason.minors) {
            currentSelectedMinorReasons = [...buttonStates.reason.minors];
        }
        document.getElementById('minorReasonModalTitle').textContent = `介入事由 (${majorReason}) - 中項目選択`;
        loadCustomMinorReasons(majorReason);
        document.getElementById('minorReasonInput').value = '';
        showModal('minorReasonModal');
    }

    function loadCustomMinorReasons(majorReason) {
        const container = document.getElementById('minorReasonButtonsContainer');
        container.innerHTML = '';

        const defaultMinors = defaultInterventionReasonData[majorReason] || [];
        const userAddedMajorMinors = (userAddedReasons[majorReason] && Array.isArray(userAddedReasons[majorReason])) ? userAddedReasons[majorReason] : [];
        const customMinorsKey = `reason-custom-${majorReason}`;
        const savedCustomMinors = JSON.parse(localStorage.getItem(customMinorsKey) || '[]');
        
        let allMinors = [...new Set([...defaultMinors, ...userAddedMajorMinors, ...savedCustomMinors])];

        allMinors.forEach(minorText => {
            const btn = document.createElement('button');
            btn.textContent = minorText;
            if (currentSelectedMinorReasons.includes(minorText)) {
                btn.classList.add('selected');
            }
            btn.onclick = function() {
                btn.classList.toggle('selected');
                if (btn.classList.contains('selected')) {
                    if (!currentSelectedMinorReasons.includes(minorText)) {
                        currentSelectedMinorReasons.push(minorText);
                    }
                } else {
                    currentSelectedMinorReasons = currentSelectedMinorReasons.filter(item => item !== minorText);
                }
            };
            container.appendChild(btn);
        });
    }
    function addCustomMinorReason() {
        if (!currentMajorReason) return;
        const input = document.getElementById('minorReasonInput');
        const value = input.value.trim();
        if (!value) return;

        const customMinorsKey = `reason-custom-${currentMajorReason}`;
        let savedCustomMinors = JSON.parse(localStorage.getItem(customMinorsKey) || '[]');
        
        const defaultMinorsForCurrentMajor = defaultInterventionReasonData[currentMajorReason] || [];
        const userAddedMinorsForCurrentMajor = userAddedReasons[currentMajorReason] || [];

        if (!savedCustomMinors.includes(value) && !defaultMinorsForCurrentMajor.includes(value) && !userAddedMinorsForCurrentMajor.includes(value)) {
            pendingMinorReasonForMlit = value;
            openMlitFactorModal(value);
        } else {
            alert(`「${value}」は既にリストまたはカスタム項目に存在します。`);
        }
        input.value = '';
    }
    
    function openMlitFactorModal(minorReason) {
        document.getElementById('mlitFactorModalTitle').textContent = `「${minorReason}」の国交省用要因を選択`;
        const container = document.getElementById('mlitFactorButtonsContainer');
        container.innerHTML = '';
        mlitFactors.forEach(factor => {
            const btn = document.createElement('button');
            btn.textContent = factor;
            btn.onclick = function() {
                container.querySelectorAll('button').forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');
            };
            container.appendChild(btn);
        });
        showModal('mlitFactorModal');
    }

    function confirmMlitFactorSelection() {
        const selectedButton = document.querySelector('#mlitFactorButtonsContainer button.selected');
        if (!selectedButton) {
            alert('国交省用要因を一つ選択してください。');
            return;
        }
        const selectedMlitFactor = selectedButton.textContent;
        const minorReason = pendingMinorReasonForMlit;

        if (minorReason && selectedMlitFactor) {
            userMlitFactorMap[minorReason] = selectedMlitFactor;
            saveMlitFactorMap();

            const customMinorsKey = `reason-custom-${currentMajorReason}`;
            let savedCustomMinors = JSON.parse(localStorage.getItem(customMinorsKey) || '[]');
            savedCustomMinors.push(minorReason);
            localStorage.setItem(customMinorsKey, JSON.stringify(savedCustomMinors));

            if (userAddedReasons.hasOwnProperty(currentMajorReason)) {
                 if (!userAddedReasons[currentMajorReason].includes(minorReason)) {
                    userAddedReasons[currentMajorReason].push(minorReason);
                    saveUserAddedReasons();
                 }
            }
            
            closeModal('mlitFactorModal');
            loadCustomMinorReasons(currentMajorReason);
            pendingMinorReasonForMlit = null;
        }
    }

    function saveMlitFactorMap() {
        localStorage.setItem(MLIT_FACTORS_KEY, JSON.stringify(userMlitFactorMap));
    }

    function removeSelectedMinorReasons() {
        if (!currentMajorReason) return;
        const container = document.getElementById('minorReasonButtonsContainer');
        const selectedButtons = container.querySelectorAll('button.selected');
        if (selectedButtons.length === 0) {
            alert("削除する中項目が選択されていません。");
            return;
        }

        let confirmMessage = "選択されている以下の中項目をカスタムリストから削除しますか？\n（デフォルトで定義された中項目は削除できません）\n";
        let itemsToRemoveFromStorage = [];
        let itemsToDeselectAndUpdate = [];

        selectedButtons.forEach(btn => {
            const minorText = btn.textContent;
            confirmMessage += `- ${minorText}\n`;
            itemsToDeselectAndUpdate.push(minorText);
            
            const isDefaultInOriginal = (defaultInterventionReasonData[currentMajorReason] || []).includes(minorText);
            const isFromUserAddedMajor = userAddedReasons.hasOwnProperty(currentMajorReason);

            if (!isDefaultInOriginal || isFromUserAddedMajor) {
                 itemsToRemoveFromStorage.push(minorText);
            } else {
                 console.log(`Cannot delete default minor reason: ${minorText} from original list.`);
            }
        });
        
        if (itemsToRemoveFromStorage.length === 0 && itemsToDeselectAndUpdate.length > 0) {
             alert("選択された項目は全て削除不可能なデフォルト項目です。");
             currentSelectedMinorReasons = currentSelectedMinorReasons.filter(item => !itemsToDeselectAndUpdate.includes(item));
             loadCustomMinorReasons(currentMajorReason);
             return;
        }

        if (!confirm(confirmMessage)) return;

        if (itemsToRemoveFromStorage.length > 0) {
            const customMinorsKey = `reason-custom-${currentMajorReason}`;
            let savedCustomMinors = JSON.parse(localStorage.getItem(customMinorsKey) || '[]');
            itemsToRemoveFromStorage.forEach(itemText => {
                savedCustomMinors = savedCustomMinors.filter(item => item !== itemText);
                delete userMlitFactorMap[itemText];
            });
            localStorage.setItem(customMinorsKey, JSON.stringify(savedCustomMinors));
            saveMlitFactorMap();

            if(userAddedReasons[currentMajorReason]){
                itemsToRemoveFromStorage.forEach(itemText => {
                    userAddedReasons[currentMajorReason] = userAddedReasons[currentMajorReason].filter(item => item !== itemText);
                });
                saveUserAddedReasons();
            }
        }
        
        currentSelectedMinorReasons = currentSelectedMinorReasons.filter(item => !itemsToDeselectAndUpdate.includes(item));
        loadCustomMinorReasons(currentMajorReason);
    }


    function confirmMinorReasonSelection() {
        const okButton = document.getElementById('minorReasonOkButton');
        setButtonProcessing(okButton, '適用中...');

        if (!currentMajorReason) {
            resetButtonState(okButton, 'OK'); 
            return;
        }

        if (currentSelectedMinorReasons.length > 0) {
            buttonStates['reason'] = {
                major: currentMajorReason,
                minors: [...currentSelectedMinorReasons]
            };
            document.getElementById('selectedReasonDisplay').textContent = `${currentMajorReason}: ${currentSelectedMinorReasons.join(' : ')}`;
        } else {
            buttonStates['reason'] = {};
             document.getElementById('selectedReasonDisplay').textContent = "未選択";
            if (currentlySelectedMajorButton) {
                currentlySelectedMajorButton.classList.remove('selected-major');
                currentlySelectedMajorButton = null;
            }
        }
        
        setTimeout(() => { 
            closeMinorReasonModalAndReset();
            resetButtonState(okButton, 'OK');
        }, 200); 
    }


    function selectPosition(elem) {
        const container = elem.closest('.position-grid');
        container.querySelectorAll('div[data-pos].selected').forEach(e => e.classList.remove('selected'));
        elem.classList.add('selected');
    }
    
    function setButtonProcessing(buttonElement, text = "送信中...") {
        if(buttonElement) {
            buttonElement.dataset.originalText = buttonElement.textContent;
            buttonElement.classList.add('processing');
            buttonElement.textContent = text;
            buttonElement.disabled = true;
        }
    }

    function resetButtonState(buttonElement, originalText) {
         if(buttonElement) {
            buttonElement.classList.remove('processing');
            buttonElement.textContent = originalText || buttonElement.dataset.originalText || "OK";
            buttonElement.disabled = false;
        }
    }

    function getCombinedProjectName() {
        const projectName = document.getElementById("projectName").value.trim();
        const tripNum = document.getElementById("tripNumber").value.trim();
        return tripNum ? `${projectName} ${tripNum}` : projectName;
    }
	
	async function sendLogInternal(dataObjectForGAS) {
    const formData = new FormData();
    for (const key in dataObjectForGAS) {
        formData.append(key, dataObjectForGAS[key]);
    }

    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), SEND_TIMEOUT);

        const response = await fetch(GAS_URL, { 
            method: "POST", 
            body: formData,
            signal: controller.signal
        });
        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`GAS request failed: ${response.status} ${response.statusText}`);
        }
        const responseText = await response.text();
        console.log(`データ送信成功:`, responseText, dataObjectForGAS["記録日時"]);

    } catch (error) {
        console.error(`データ送信失敗/タイムアウト:`, error, dataObjectForGAS["記録日時"]);
        addLogToOfflineQueue({
            formDataObject: dataObjectForGAS, 
            timestamp: dataObjectForGAS["記録日時"] 
        });
    }
}

	function confirmModal() {
        const isUpdate = editingPinData !== null && editingPinData.UUID;
        const localEditingData = editingPinData; 

        if (!isUpdate && (!pendingLog || !pendingLog.latlng)) {
            console.error("記録位置が設定されていません。");
            editingPinData = null;
            pendingLog = null;
            return;
        }
        
        closeModal('customModal');

        const latlng = isUpdate ? L.latLng(localEditingData["緯度"], localEditingData["経度"]) : pendingLog.latlng;
        const areaInfo = getAreaInfoFromPoint(latlng);
        const directionalArea = getDirectionalAreaInfo(areaInfo);
        const shapePresence = getShapePresence(directionalArea.shape1);

        const isIntersectionNearbyChecked = document.getElementById('isIntersectionNearby').checked;
        let finalShape2 = directionalArea.shape2;

        if (isIntersectionNearbyChecked) {
            finalShape2 = "交差点付近";
        }

        const extraData = {};
        fields.forEach(field => {
            if (field.id === 'reason') {
                if (buttonStates.reason && buttonStates.reason.major) {
                    extraData.interventionReasonMajor = buttonStates.reason.major;
                    extraData.interventionReasonMinor = buttonStates.reason.minors ? buttonStates.reason.minors.join(' : ') : "";
                } else {
                    extraData.interventionReasonMajor = "";
                    extraData.interventionReasonMinor = "";
                }
            } else {
                extraData[field.id] = getSelectedTexts(`dynamicFields-${field.id}-buttons`);
            }
        });
        extraData.targetPos = document.querySelector('#customModal .position-grid div[data-pos].selected')?.dataset.pos || '';
        extraData.memo = document.getElementById('freeMemo').value.trim();
        
        const projectName = document.getElementById("projectName").value.trim();
        const tripNumber = document.getElementById("tripNumber").value.trim();
        
        const recordTimeInput = document.getElementById('interventionRecordTime').value;
		let recordTime;
		if (recordTimeInput) {
			recordTime = new Date(recordTimeInput).toISOString();
		} else {
            recordTime = isUpdate ? localEditingData["記録日時"] : new Date().toISOString();
        }

        const dataToSubmit = {
            "recordType": isUpdate ? "update" : "intervention",
            "UUID": isUpdate ? localEditingData.UUID : crypto.randomUUID(), 
            "記録日時": recordTime,
            "緯度": latlng.lat,
            "経度": latlng.lng,
            "操作種別": isUpdate ? localEditingData["操作種別"] : pendingLog.type,
            "往復方向": currentDirection,
            "天候": selectedWeather, 
            "視界": selectedVisibility,
            "路面状況": selectedRoadCondition,
            "案件名": tripNumber ? `${projectName} ${tripNumber}` : projectName,
            "案件名（案件部）": projectName,
            "便数": tripNumber,
            "エリア番号": areaInfo ? areaInfo.name : "",
            "介入事由（大項目）": extraData.interventionReasonMajor || "",
            "介入事由（中項目）": extraData.interventionReasonMinor || "",
            "国交省用要因": getMlitFactorForMinorReason(extraData.interventionReasonMinor),
            "要因": extraData.factor || "",
            "介入操作": extraData.operation || "",
            "自車状態": extraData.ego || "",
            "相手の動き": extraData.target || "",
            "相手位置": extraData.targetPos || "",
            "メモ": extraData.memo || "",
            "モーダルタイプ": "介入",
            "道路形状1": directionalArea.shape1,
            ...shapePresence,
            "道路形状2": finalShape2,
            "道路形状3": directionalArea.shape3,
            "L4区間内外": directionalArea.l4_status,
            "国交省外": directionalArea.mlit_extra,
        };

        if (isUpdate) {
            let markerToUpdate = null;
            markerLayerGroup.eachLayer(layer => {
                if (layer._customData && layer._customData.UUID === dataToSubmit.UUID) markerToUpdate = layer;
            });
            if (markerToUpdate) {
                markerToUpdate._customData = dataToSubmit;
                const newPopupContent = createPopupContent(dataToSubmit, areaInfo, L.stamp(markerToUpdate));
                markerToUpdate.setPopupContent(newPopupContent).closePopup();
            }
        } else {
            createAndAddMarker(dataToSubmit, areaInfo);
        }
        
        sendLogInternal(dataToSubmit);
        
        editingPinData = null;
        pendingLog = null;
    }

	function confirmNonInterventionModal() {
    const memoText = document.getElementById('nonInterventionMemo').value.trim();
    const isHiyari = document.getElementById('nonInterventionHiyari').checked;
    const isMemoOnly = document.getElementById('nonInterventionMemoOnly').checked;
    let signalDetectionValue = "";

    // 複数の "signalDetection" ラジオボタングループから値を取得するロジックを修正
    const signalRadioGroups = document.querySelectorAll('input[name="signalDetection"]');
    for (let i = 0; i < signalRadioGroups.length; i++) {
        if (signalRadioGroups[i].checked) {
            signalDetectionValue = signalRadioGroups[i].value;
            break; // 最初に見つかったチェック済みのものを採用
        }
    }
    const signalOtherMemoText = document.getElementById('signalOtherMemo').value.trim();
    
    const projectName = document.getElementById("projectName").value.trim();
    const tripNumber = document.getElementById("tripNumber").value.trim();

    const processAndSend = (latlngForLog) => {
        closeModal('nonInterventionModal');

        let interventionReasonMinorText = "";
        let hiyariMemoFactor = "";
        if (isHiyari) hiyariMemoFactor = "ヒヤリ";
        if (isMemoOnly && !hiyariMemoFactor) hiyariMemoFactor = "メモのみ";
        else if (isMemoOnly) hiyariMemoFactor += (hiyariMemoFactor ? " : " : "") + "メモのみ";

        let signalFactorText = "";
        if (signalDetectionValue) {
            signalFactorText = signalDetectionValue;
            if (signalDetectionValue === "その他" && signalOtherMemoText) {
                signalFactorText += ` (${signalOtherMemoText})`;
            }
        }

        if (hiyariMemoFactor && signalFactorText) interventionReasonMinorText = `${hiyariMemoFactor} : ${signalFactorText}`;
        else if (hiyariMemoFactor) interventionReasonMinorText = hiyariMemoFactor;
        else if (signalFactorText) interventionReasonMinorText = signalFactorText;

        const areaInfo = getAreaInfoFromPoint(latlngForLog);
        const directionalArea = getDirectionalAreaInfo(areaInfo);
        const shapePresence = getShapePresence(directionalArea.shape1);

        const dataToSubmit = {
            "recordType": "intervention",
            "UUID": crypto.randomUUID(),
            "記録日時": (pendingLog && pendingLog.time) ? new Date(pendingLog.time).toISOString() : new Date().toISOString(),
            "緯度": latlngForLog.lat,
            "経度": latlngForLog.lng,
            "操作種別": "非介入記録",
            "往復方向": currentDirection,
            "天候": selectedWeather,
            "視界": selectedVisibility,
            "路面状況": selectedRoadCondition,
            "案件名": tripNumber ? `${projectName} ${tripNumber}` : projectName,
            "案件名（案件部）": projectName,
            "便数": tripNumber,
            "エリア番号": areaInfo ? areaInfo.name : "",
            "介入事由（大項目）": "介入なし",
            "介入事由（中項目）": interventionReasonMinorText,
            "国交省用要因": "その他",
            "要因": "", "介入操作": "", "自車状態": "", "相手の動き": "", "相手位置": "",
            "メモ": memoText,
            "モーダルタイプ": "非介入",
            "道路形状1": directionalArea.shape1,
            ...shapePresence,
            "道路形状2": directionalArea.shape2,
            "道路形状3": directionalArea.shape3,
            "L4区間内外": directionalArea.l4_status,
            "国交省外": directionalArea.mlit_extra,
        };

        createAndAddMarker(dataToSubmit, areaInfo);
        sendLogInternal(dataToSubmit);
    };

    if (pendingLog && pendingLog.latlng) {
        processAndSend(pendingLog.latlng);
    } else {
        alert("記録位置が指定されていません。地図をダブルクリックして位置を指定してください。");
    }
}

    function sendLogForStreetParking(data) {
    const projectName = data.project;
    const tripNumber = data.trip || '';
    const areaInfo = data.areaInfo;
    const directionalArea = getDirectionalAreaInfo(areaInfo, data.direction);
    const shapePresence = getShapePresence(directionalArea.shape1);
    
    const dataToSubmit = {
        "recordType": "intervention",
        "UUID": crypto.randomUUID(),
        "記録日時": new Date(data.recordTime).toISOString(),
        "緯度": data.lat,
        "経度": data.lng,
        "操作種別": "非介入記録",
        "往復方向": data.direction,
        "天候": selectedWeather, 
        "視界": selectedVisibility,
        "路面状況": selectedRoadCondition,
        "案件名": tripNumber ? `${projectName} ${tripNumber}` : projectName,
        "案件名（案件部）": projectName,
        "便数": tripNumber,
        "エリア番号": areaInfo ? areaInfo.name : "",
        "介入事由（大項目）": "介入なし",
        "介入事由（中項目）": "路駐回避成功",
        "国交省用要因": "路上駐車回避",
        "要因": "", "介入操作": "", "自車状態": "", "相手の動き": "", "相手位置": "",
        "メモ": "",
        "モーダルタイプ": "非介入",
        "道路形状1": directionalArea.shape1,
        ...shapePresence,
        "道路形状2": directionalArea.shape2,
        "道路形状3": directionalArea.shape3,
        "L4区間内外": directionalArea.l4_status,
        "国交省外": directionalArea.mlit_extra,
    };

    createAndAddMarker(dataToSubmit, areaInfo);
    sendLogInternal(dataToSubmit);
}
    function createPopupContent(pinData, areaInfo, markerId) {
        const areaName = areaInfo ? areaInfo.name : 'エリア外';
        const isNonInterventionType = pinData["操作種別"] === "非介入記録" || pinData["介入事由（大項目）"] === "介入なし";
        const projectDisplay = `案件: ${pinData["案件名（案件部）"] || ''}<br>便: ${pinData["便数"] || ''}`;
        
        const direction = pinData['往復方向'] || '往路';
        const outboundClass = direction === '往路' ? 'selected' : '';
        const inboundClass = direction === '復路' ? 'selected' : '';

        const directionButtons = `
            <div class="popup-direction-buttons">
                <button class="${outboundClass}" onclick="togglePinDirection(${markerId}, '往路')">往路</button>
                <button class="${inboundClass}" onclick="togglePinDirection(${markerId}, '復路')">復路</button>
            </div>
        `;

        let mainContent;
        const environmentInfo = `天候/視界/路面: ${pinData["天候"] || '‐'}/${pinData["視界"] || '‐'}/${pinData["路面状況"] || '‐'}<br>`;
        
        const recordDate = new Date(pinData["記録日時"]);
        const formattedTime = `${recordDate.getFullYear()}/${String(recordDate.getMonth() + 1).padStart(2, '0')}/${String(recordDate.getDate()).padStart(2, '0')} ${String(recordDate.getHours()).padStart(2, '0')}:${String(recordDate.getMinutes()).padStart(2, '0')}:${String(recordDate.getSeconds()).padStart(2, '0')}`;

        if (isNonInterventionType) {
            if (pinData["介入事由（中項目）"] === "路駐回避成功") {
                mainContent = `非介入記録 (路駐回避成功)<br>${formattedTime}<br>${projectDisplay}<br>${areaName}<br>${environmentInfo}大項目: ${pinData["介入事由（大項目）"]}<br>中項目: ${pinData["介入事由（中項目）"]}`;
            } else {
                mainContent = `非介入記録<br>${formattedTime}<br>${projectDisplay}<br>${areaName}<br>${environmentInfo}大項目: ${pinData["介入事由（大項目）"] || '介入なし'}<br>中項目: ${pinData["介入事由（中項目）"] || 'N/A'}<br>メモ: ${(pinData["メモ"] || '').substring(0,20)}${(pinData["メモ"] || '').length > 20 ? '...' : ''}`;
            }
        } else {
            mainContent = `${pinData["操作種別"]}<br>${formattedTime}<br>${projectDisplay}<br>${areaName}<br>${environmentInfo}介入事由(大): ${pinData["介入事由（大項目）"] || ''}<br>介入事由(中): ${pinData["介入事由（中項目）"] || ''}<br>要因: ${pinData["要因"] || ''}<br>自車: ${pinData["自車状態"] || ''}<br>相手: ${pinData["相手状態"] || ''}<br>相手位置: ${pinData["相手位置"] || ''}<br>メモ: ${pinData["メモ"] || ''}`;
        }
        
        const editButton = `<button class="popup-edit-button" onclick="openModalForEdit(${markerId})">この記録を編集</button>`;
        const deleteButton = `<button class="popup-delete-button" onclick="deletePin(${markerId})">このピンを削除</button>`;
        
        return `${mainContent}${directionButtons}${editButton}${deleteButton}`;
    }

    /**
 * ★★★ ここからが置き換えるコード（createAndAddMarker） ★★★
 */
function createAndAddMarker(pinData, areaInfo) {
    const markerIcon = (pinData["操作種別"] === "非介入記録" || pinData["介入事由（大項目）"] === "介入なし") ? yellowIcon : blueIcon;
    const latlng = L.latLng(parseFloat(pinData["緯度"]), parseFloat(pinData["経度"]));
    const marker = L.marker(latlng, {
        draggable: true,
        icon: markerIcon
    });

    const markerId = L.stamp(marker);
    pinData.markerId = markerId; 
    
    const popupContent = createPopupContent(pinData, areaInfo, markerId);
    marker.bindPopup(popupContent);
    
    marker._customData = pinData; // ファイルから読み込んだデータをそのままマーカーに格納

    marker.on('dragend', function(e) {
        const newLatLng = e.target.getLatLng();
        const newAreaInfo = getAreaInfoFromPoint(newLatLng);
        
        e.target._customData["緯度"] = newLatLng.lat;
        e.target._customData["経度"] = newLatLng.lng;
        e.target._customData["エリア番号"] = newAreaInfo ? newAreaInfo.name : "";

        if (newAreaInfo) {
            const directionalArea = getDirectionalAreaInfo(newAreaInfo, e.target._customData['往復方向']);
            const shapePresence = getShapePresence(directionalArea.shape1);
            e.target._customData["道路形状1"] = directionalArea.shape1;
            e.target._customData["道路形状2"] = directionalArea.shape2;
            e.target._customData["道路形状3"] = directionalArea.shape3;
            e.target._customData["L4区間内外"] = directionalArea.l4_status;
            e.target._customData["国交省外"] = directionalArea.mlit_extra;
            Object.assign(e.target._customData, shapePresence);
        } else {
            e.target._customData["道路形状1"] = "";
            e.target._customData["道路形状2"] = "";
            e.target._customData["道路形状3"] = "";
            e.target._customData["L4区間内外"] = "";
            e.target._customData["国交省外"] = "";
            e.target._customData["信号有無"] = "無";
            e.target._customData["横断歩道有無"] = "無";
            e.target._customData["バス停有無"] = "無";
            e.target._customData["歩者分離有無"] = "無";
        }

        const updatedPopupContent = createPopupContent(e.target._customData, newAreaInfo, L.stamp(e.target));
        e.target.setPopupContent(updatedPopupContent);

        updateMarkerPosition(e.target._customData);
    });

    marker.addTo(markerLayerGroup);
    return marker;
}
/**
 * ★★★ ここまでが置き換えるコード（createAndAddMarker） ★★★
 */

    function togglePinDirection(markerId, newDirection) {
    let targetMarker = null;
    markerLayerGroup.eachLayer(layer => {
        if (L.stamp(layer) === markerId) {
            targetMarker = layer;
        }
    });

    if (targetMarker && targetMarker._customData['往復方向'] !== newDirection) {
        targetMarker._customData['往復方向'] = newDirection;
        
        const areaInfo = getAreaInfoFromPoint(targetMarker.getLatLng());
        
        // ★★★ エリア内外の判定によるデータ更新ロジックを追加 ★★★
        if (areaInfo) {
            const directionalArea = getDirectionalAreaInfo(areaInfo, newDirection);
            const shapePresence = getShapePresence(directionalArea.shape1);
            targetMarker._customData["道路形状1"] = directionalArea.shape1;
            targetMarker._customData["道路形状2"] = directionalArea.shape2;
            targetMarker._customData["道路形状3"] = directionalArea.shape3;
            targetMarker._customData["L4区間内外"] = directionalArea.l4_status;
            targetMarker._customData["国交省外"] = directionalArea.mlit_extra;
            Object.assign(targetMarker._customData, shapePresence);
        } else {
            // エリア外の場合は関連情報をクリア
            targetMarker._customData["道路形状1"] = "";
            targetMarker._customData["道路形状2"] = "";
            targetMarker._customData["道路形状3"] = "";
            targetMarker._customData["L4区間内外"] = "";
            targetMarker._customData["国交省外"] = "";
            targetMarker._customData["信号有無"] = "無";
            targetMarker._customData["横断歩道有無"] = "無";
            targetMarker._customData["バス停有無"] = "無";
            targetMarker._customData["歩者分離有無"] = "無";
        }

        const newPopupContent = createPopupContent(targetMarker._customData, areaInfo, markerId);
        targetMarker.setPopupContent(newPopupContent);

        updateMarkerPosition(targetMarker._customData);
    }
}


    function deletePin(markerId) {
        let markerToDelete = null;
        markerLayerGroup.eachLayer(function (layer) {
            if (L.stamp(layer) === markerId) {
                markerToDelete = layer;
            }
        });

        if (markerToDelete) {
            const pinData = markerToDelete._customData;
            if (confirm(`以下の記録を削除しますか？\n日時: ${pinData["記録日時"]}`)) {
                markerLayerGroup.removeLayer(markerToDelete);
                
                const deleteData = {
                    recordType: 'delete',
                    'UUID': pinData["UUID"], 
                    '案件名': pinData["案件名"] 
                };
                
                sendLogInternal(deleteData);
                alert('ピンを削除し、削除情報を送信しました。');
            }
        }
    }
    function updateMarkerPosition(pinData) {
    const formData = new FormData();
    
    // ★★★ 修正点：pinDataオブジェクトの全ての情報をFormDataに追加する ★★★
    for (const key in pinData) {
        if (pinData.hasOwnProperty(key)) {
            formData.append(key, pinData[key]);
        }
    }
    // recordTypeを明示的に"update"に設定
    formData.set("recordType", "update");

    fetch(GAS_URL, { method: "POST", body: formData }) 
    .then(res => res.text())
    .then(txt => console.log("マーカー位置更新成功:", txt))
    .catch(err => { 
        console.error("マーカー位置更新失敗:", err);
        // エラーが発生した場合、オフラインキューに追加する
        addLogToOfflineQueue({
            formDataObject: pinData, 
            timestamp: pinData["記録日時"] 
        });
    });
}

    function checkProjectAndTripNumber() {
        const projectNameInput = document.getElementById("projectName");
        if (!projectNameInput.value.trim()) {
            projectNameInput.classList.add("warning");
            projectNameInput.placeholder = "案件名を入力してください";
        } else {
            projectNameInput.classList.remove("warning");
            projectNameInput.placeholder = "案件名を入力";
        }
    }
    
    // --- Comprehensive Settings Save/Load ---
    const APP_SETTINGS_LOCAL_KEY = 'interventionMapAppSettings';

    function saveAllSettings() {
        if (!confirm("現在のすべての設定（エリア、バス停、お気に入り等）をファイルに保存しますか？")) {
            return;
        }

        drawnItems.eachLayer(layer => {
            if (!layer.feature || !layer.feature.type || !layer.feature.geometry) {
                console.warn('保存できないデータ形式のレイヤーを検出したため、変換処理を実行します。', layer);
                const originalProperties = layer.feature?.properties || {};
                layer.feature = layer.toGeoJSON();
                layer.feature.type = 'Feature';
                layer.feature.properties = { ...originalProperties, ...layer.feature.properties };
            }
        });

        const customButtons = {};
        ['factor', 'ego', 'target'].forEach(fieldId => {
            customButtons[fieldId] = JSON.parse(localStorage.getItem(`${fieldId}-custom`) || '[]');
        });

        const settingsData = {
            version: "1.1",
            savedAt: new Date().toISOString(),
            appSettings: {
                projectName: document.getElementById('projectName').value.trim(),
                tripNumber: document.getElementById('tripNumber').value.trim(),
                direction: currentDirection
            },
            areas: drawnItems.toGeoJSON(),
            busStops: getBusStops(),
            favorites: favoriteConfigurations,
            customButtons: customButtons,
            userAddedReasons: userAddedReasons,
            // ★★★ 保存形式を分離 ★★★
            customAreaInfoOptions_outbound: JSON.parse(localStorage.getItem('customAreaInfoOptions_outbound') || '[]'),
            customAreaInfoOptions_inbound: JSON.parse(localStorage.getItem('customAreaInfoOptions_inbound') || '[]')
        };
        
        const blob = new Blob([JSON.stringify(settingsData, null, 2)], { type: "application/json" });
        const fileName = `設定バックアップ_${getCurrentJSTString('date')}.json`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert(`${fileName}として設定を保存しました。`);
    }

    function loadAllSettings(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const settingsJson = e.target.result;
                loadAllSettingsFromFileContent(settingsJson);
                alert(`ファイル「${file.name}」から設定を復元しました。`);
            } catch (err) {
                alert(`設定ファイルの読み込みに失敗しました: ${err.message}`);
                console.error(err);
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset file input
    }
    
    function loadAllSettingsFromFileContent(jsonContent) {
        const data = JSON.parse(jsonContent);

        if (data.appSettings) {
            document.getElementById('projectName').value = data.appSettings.projectName || '';
            document.getElementById('tripNumber').value = data.appSettings.tripNumber || '';
            if (data.appSettings.direction) {
                setDirection(data.appSettings.direction);
            }
        }
        
        if (data.areas && data.areas.features && data.areas.features.length > 0) {
            importGeoJSONFromData(data.areas);
        } else {
            drawnItems.clearLayers();
            labelMap.clear();
        }
        
        if (data.busStops && Array.isArray(data.busStops)) {
            saveBusStops(data.busStops);
        }

        if (data.favorites) {
            favoriteConfigurations = data.favorites;
            saveFavorites();
        }

        if (data.customButtons) {
            Object.keys(data.customButtons).forEach(fieldId => {
                localStorage.setItem(`${fieldId}-custom`, JSON.stringify(data.customButtons[fieldId] || '[]'));
            });
        }
        if (data.userAddedReasons) {
            localStorage.setItem('userAddedInterventionReasons', JSON.stringify(data.userAddedReasons));
            loadUserAddedReasons();
        }
        if (data.customAreaInfoOptions_outbound) {
            localStorage.setItem('customAreaInfoOptions_outbound', JSON.stringify(data.customAreaInfoOptions_outbound));
        }
        if (data.customAreaInfoOptions_inbound) {
            localStorage.setItem('customAreaInfoOptions_inbound', JSON.stringify(data.customAreaInfoOptions_inbound));
        }
        // 古い設定ファイルとの後方互換性のため
        if (data.customAreaInfoOptions && !data.customAreaInfoOptions_outbound && !data.customAreaInfoOptions_inbound) {
             localStorage.setItem('customAreaInfoOptions_outbound', JSON.stringify(data.customAreaInfoOptions));
             localStorage.setItem('customAreaInfoOptions_inbound', JSON.stringify(data.customAreaInfoOptions));
        }

        createDynamicFields('dynamicFields', fields);
    }

    // --- Favorite Functions ---
    function loadFavorites() {
        const storedFavorites = localStorage.getItem(FAVORITES_STORAGE_KEY);
        if (storedFavorites) {
            try {
                favoriteConfigurations = JSON.parse(storedFavorites);
            } catch (e) {
                console.error("Failed to parse favorites from localStorage", e);
                favoriteConfigurations = {};
            }
        }
        renderFavoriteShortcutButtons();
    }

    function saveFavorites() {
        localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(favoriteConfigurations));
        renderFavoriteShortcutButtons();
    }
    
    function openSaveFavoriteModal() {
        if (!buttonStates.reason || !buttonStates.reason.major) {
            alert("お気に入りに登録するには、少なくとも介入事由（大項目）を選択してください。");
            return;
        }
        document.getElementById('favoriteNameInput').value = '';
        showModal('saveFavoriteModal');
    }

    function saveFavoritePreset() {
        const nameInput = document.getElementById('favoriteNameInput');
        const customName = nameInput.value.trim();

        if (!customName) {
            alert("お気に入りの名前を入力してください。");
            return;
        }
        
        if (!buttonStates.reason || !buttonStates.reason.major) {
            alert("お気に入りに登録するには、少なくとも介入事由（大項目）を選択してください。");
            return;
        }

        // 要因、自車状態、相手の動き、介入操作、相手の位置、メモなど、モーダルで設定可能な項目をすべて保存する
        const favDetails = {
            interventionReasonMajor: buttonStates.reason.major,
            interventionReasonMinor: buttonStates.reason.minors ? buttonStates.reason.minors.join(' : ') : "",
            factor: getSelectedTexts('dynamicFields-factor-buttons'),
            ego: getSelectedTexts('dynamicFields-ego-buttons'),
            target: getSelectedTexts('dynamicFields-target-buttons'),
            operation: getSelectedTexts('dynamicFields-operation-buttons'),
            targetPos: document.querySelector('#customModal .position-grid div[data-pos].selected')?.dataset.pos || '',
            memo: document.getElementById('freeMemo').value.trim()
        };

        const favId = 'fav_' + Date.now();
        favoriteConfigurations[favId] = {
            label: customName,
            details: favDetails
        };

        saveFavorites();
        alert(`「${customName}」をお気に入り登録しました。`);
        closeModal('saveFavoriteModal');
        // 続けてメインモーダルも閉じる
        closeModal('customModal'); 
    }
    
    function renderFavoriteShortcutButtons() {
        if (!favoriteButtonsControl || !favoriteButtonsControl.getContainer()) return;
        const container = favoriteButtonsControl.getContainer();
        container.innerHTML = ''; 

        Object.keys(favoriteConfigurations).sort((a, b) => {
            const labelA = favoriteConfigurations[a].label.toLowerCase();
            const labelB = favoriteConfigurations[b].label.toLowerCase();
            if (labelA < labelB) return -1;
            if (labelA > labelB) return 1;
            return 0;
        }).forEach(slotId => {
            const fav = favoriteConfigurations[slotId];
            if (fav && fav.details) { 
                const button = L.DomUtil.create('button', '', container);
                button.textContent = fav.label;
                button.title = `お気に入り ${fav.label}:\n大項目: ${fav.details.interventionReasonMajor}\n中項目: ${fav.details.interventionReasonMinor || 'なし'}`;
                L.DomEvent.on(button, 'click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    if (isDeleteFavoriteModeActive) {
                        deleteFavoritePreset(slotId);
                    } else {
                        activateFavoriteLogging(slotId, button);
                    }
                });
            }
        });
        
        const deleteButton = L.DomUtil.create('button', '', container);
        deleteButton.id = 'deleteFavoriteButton';
        deleteButton.textContent = 'お気に入り削除';
        deleteButton.style.marginTop = '5px';
        L.DomEvent.on(deleteButton, 'click', toggleDeleteFavoriteMode);
    }
    function activateFavoriteLogging(slotId, buttonElement) {
        // ★★★ ここから追加 ★★★
        // もし、すでに選択されているお気に入りボタンを再度クリックした場合は、
        // 選択を解除して処理を終了します（トグル機能）
        if (activeFavoriteSlotToLog === slotId) {
            resetActiveFavoriteLogging();
            return;
        }
        // ★★★ ここまで追加 ★★★

        if (isWaitingForStreetParkingDoubleClick) cancelStreetParkingDoubleClick();
        
        // 他のお気に入りが選択されていれば、一旦リセット
        resetActiveFavoriteLogging(); 

        // 新しいお気に入りを選択状態にする
        activeFavoriteSlotToLog = slotId;
        if (buttonElement) buttonElement.classList.add('favorite-active');
        
        console.log(`${favoriteConfigurations[slotId].label} 記録待機中... 地図をクリック/タップしてください。`);
        const streetParkingButton = document.getElementById('streetParkingMainButton');
        if(streetParkingButton) streetParkingButton.innerHTML = `${favoriteConfigurations[slotId].label} 記録中`;
    }
    
    function resetActiveFavoriteLogging() {
        if (activeFavoriteSlotToLog) {
            const buttons = favoriteButtonsControl.getContainer().querySelectorAll('button');
            buttons.forEach(btn => btn.classList.remove('favorite-active'));
            activeFavoriteSlotToLog = null;
            const streetParkingButton = document.getElementById('streetParkingMainButton');
            if(streetParkingButton && streetParkingButton.innerHTML.includes("記録中")) {
                 streetParkingButton.innerHTML = '路駐回避成功';
            }
        }
        pendingFavoriteLog = null;
    }
	function logFavorite(slotId, latlng) {
		if (!validatePrerequisites()) {
			resetActiveFavoriteLogging();
			return;
		}
		if (!favoriteConfigurations[slotId] || !favoriteConfigurations[slotId].details) {
			console.error("お気に入りの詳細データが見つかりません:", slotId);
			resetActiveFavoriteLogging();
			return;
		}

		const favDetails = favoriteConfigurations[slotId].details;
		const favName = favoriteConfigurations[slotId].label;
		console.log(`お気に入り「${favName}」をモーダルに展開します...`);

		// --- ここからが新しいロジック ---

		// 1. 新規記録の準備（openModalの初期化処理を一部実行）
		editingPinData = null; 
		buttonStates = {};
		pendingLog = { latlng, type: `お気に入り記録(${favName})`, time: getCurrentJSTString() };
		document.getElementById('interventionRecordTime').value = getCurrentJSTString('datetime-local');
		
		// 2. お気に入りの詳細情報を読み込み、ボタン選択状態などを準備
		if (favDetails.interventionReasonMajor) {
			buttonStates.reason = {
				major: favDetails.interventionReasonMajor,
				minors: favDetails.interventionReasonMinor ? favDetails.interventionReasonMinor.split(' : ') : []
			};
		}
		// createDynamicFieldsが参照するために、一時的にeditingPinDataにお気に入りの情報をセット
		editingPinData = {
			"介入事由（大項目）": favDetails.interventionReasonMajor || "",
			"介入事由（中項目）": favDetails.interventionReasonMinor || "",
			"要因": favDetails.factor || "",
			"自車状態": favDetails.ego || "",
			"相手の動き": favDetails.target || "",
			"介入操作": favDetails.operation || "",
			"相手位置": favDetails.targetPos || "",
			"メモ": favDetails.memo || ""
		};

		// 3. モーダルの各項目にお気に入りの内容を反映させる
		createDynamicFields('dynamicFields', fields);
		
		document.querySelectorAll('#customModal .position-grid div[data-pos].selected').forEach(e => e.classList.remove('selected'));
		if (editingPinData["相手位置"]) {
			const posDiv = document.querySelector(`#customModal .position-grid div[data-pos="${editingPinData["相手位置"]}"]`);
			if (posDiv) posDiv.classList.add('selected');
		}
		document.getElementById('freeMemo').value = editingPinData["メモ"] || "";

		// 4. モーダルを開く
		document.querySelector('#customModalTitle').textContent = `お気に入り「${favName}」から記録（内容確認・修正可）`;
		showModal("customModal");
		resetDetailsTab();

		// 5. お気に入り記録モードを終了
		resetActiveFavoriteLogging();
		console.log("お気に入りの内容を展開しました。内容を確認・修正してOKを押してください。");
	}

    function toggleDeleteFavoriteMode() {
        isDeleteFavoriteModeActive = !isDeleteFavoriteModeActive;
        const deleteButton = document.getElementById('deleteFavoriteButton');
        const favButtons = favoriteButtonsControl.getContainer().querySelectorAll('button');

        if (isDeleteFavoriteModeActive) {
            deleteButton.classList.add('delete-mode-active');
            deleteButton.textContent = '削除対象を選択';
            favButtons.forEach(btn => { if(btn.id !== 'deleteFavoriteButton') btn.classList.add('delete-target')});
             if (activeFavoriteSlotToLog) resetActiveFavoriteLogging(); 
             if (isWaitingForStreetParkingDoubleClick) cancelStreetParkingDoubleClick();

        } else {
            deleteButton.classList.remove('delete-mode-active');
            deleteButton.textContent = 'お気に入り削除';
            favButtons.forEach(btn => btn.classList.remove('delete-target'));
        }
    }

    function deleteFavoritePreset(slotId, buttonElement) {
        if (!isDeleteFavoriteModeActive) return;

        if (favoriteConfigurations[slotId]) {
            if (confirm(`お気に入り「${favoriteConfigurations[slotId].label}」を削除しますか？`)) {
                delete favoriteConfigurations[slotId];
                saveFavorites(); 
                console.log(`お気に入り ${slotId} を削除しました。`);
            }
        }
        if (Object.keys(favoriteConfigurations).length === 0 || !confirm("続けて他のお気に入りを削除しますか？")) {
            toggleDeleteFavoriteMode(); 
        } else {
            const favButtons = favoriteButtonsControl.getContainer().querySelectorAll('button');
            favButtons.forEach(btn => {if(btn.id !== 'deleteFavoriteButton') btn.classList.add('delete-target')});

        }
    }
    
    // --- Bus Stop Functions ---
    function toggleBusStopForm() {
        const form = document.getElementById('busStopForm');
        const button = document.getElementById('toggleBusStopFormButton');
        if (form.style.display === 'none') {
            form.style.display = 'flex';
            button.classList.add('active');
        } else {
            form.style.display = 'none';
            button.classList.remove('active');
        }
    }
    function getBusStops() {
        return JSON.parse(localStorage.getItem(BUS_STOPS_KEY) || '[]');
    }

    function saveBusStops(busStops) {
        localStorage.setItem(BUS_STOPS_KEY, JSON.stringify(busStops));
        renderBusStopButtons();
    }

    function addBusStop() {
        const input = document.getElementById('newBusStopName');
        const newName = input.value.trim();
        if (!newName) {
            alert('バス停名を入力してください。');
            return;
        }
        let busStops = getBusStops();
        if (busStops.includes(newName)) {
            alert('そのバス停名は既に登録されています。');
            return;
        }
        busStops.push(newName);
        busStops.sort((a, b) => a.localeCompare(b, 'ja'));
        saveBusStops(busStops);
        input.value = '';
    }

    function deleteAllBusStops() {
        if (getBusStops().length === 0) {
            alert('削除するバス停がありません。');
            return;
        }
        if (confirm(`登録されている全てのバス停を削除しますか？この操作は元に戻せません。`)) {
            saveBusStops([]);
        }
    }
    
    function loadBusStops() {
        renderBusStopButtons();
    }
    
    function renderBusStopButtons() {
        const container = document.getElementById('bus-stop-buttons-container');
        if (!container) return;
        container.innerHTML = '';
        const busStops = getBusStops();

        busStops.forEach(name => {
            const wrapper = L.DomUtil.create('div', '', container);
            wrapper.style.position = 'relative';

            const mainButton = L.DomUtil.create('button', 'busstop-main-button', wrapper);
            mainButton.textContent = name;
            
            L.DomEvent.on(mainButton, 'click', (e) => {
                L.DomEvent.stopPropagation(e);
                // ★★★ ここで入力チェックを行う ★★★
                if (!validateTripInfo()) {
                    return;
                }
                openBusStopModal(name); 
            });
        });
    }
    function openBusStopModal(busStopName) {
        document.getElementById('busStopTime').value = getCurrentJSTString('datetime-local');
        
        currentBusStopInfo = { busStopName }; 
        document.getElementById('busStopRecordModalTitle').textContent = `バス停通過記録: ${busStopName}`;
        
        document.getElementById('busStopType').value = '自動';

        const lastRecorder = localStorage.getItem('lastRecorderName') || '';
        
        // 記録者名のみを引き継ぎ、他は空にする
        document.getElementById('recorder').value = lastRecorder;
        document.getElementById('temperature').value = '';
        document.getElementById('odo').value = '';
        document.getElementById('battery').value = '';
        
        // ★★★ 天候の連携：マップの天候(selectedWeather)を反映させる ★★★
        document.querySelectorAll('#weather-buttons button').forEach(btn => {
            if (btn.textContent === selectedWeather) { // lastWeatherの代わりにselectedWeatherを使用
                btn.classList.add('selected');
            } else {
                btn.classList.remove('selected');
            }
        });
        document.getElementById('weather_other_field').style.display = (selectedWeather === 'その他') ? 'block' : 'none';
        
        // ★★★ 発着のデフォルト選択：「出発」をデフォルトで選択状態にする ★★★
        document.querySelectorAll('#departure-arrival-buttons button').forEach(btn => {
            // "出発"ボタンをデフォルトで選択状態にする
            if (btn.textContent === '出発') {
                btn.classList.add('selected');
            } else {
                btn.classList.remove('selected');
            }
        });

        document.getElementById('weather_other').value = '';
        document.getElementById('passengersOn').value = '';
        document.getElementById('passengersOff').value = '';
        document.getElementById('isDelayed').checked = false;
        document.getElementById('delayDetails').value = '';

        showModal('busStopRecordModal');
    }

    function selectWeather(button, weather) {
        document.querySelectorAll('#weather-buttons button').forEach(btn => btn.classList.remove('selected'));
        button.classList.add('selected');
        document.getElementById('weather_other_field').style.display = (weather === 'その他') ? 'block' : 'none';
    }
    
    function selectDepartureArrival(button) {
        if (button.classList.contains('selected')) {
            button.classList.remove('selected');
        } else {
            document.querySelectorAll('#departure-arrival-buttons button').forEach(btn => btn.classList.remove('selected'));
            button.classList.add('selected');
        }
    }
    
	function confirmBusStopRecord() {
    // 1. データを収集
    const recorderName = document.getElementById('recorder').value.trim();
    const temperature = document.getElementById('temperature').value.trim();
    const odo = document.getElementById('odo').value.trim();
    const battery = document.getElementById('battery').value.trim();
    const selectedWeatherBtn = document.querySelector('#weather-buttons button.selected');
    const weather = selectedWeatherBtn ? selectedWeatherBtn.textContent : '';
    
    const selectedDepartureArrivalBtn = document.querySelector('#departure-arrival-buttons button.selected');
    const departureArrivalType = selectedDepartureArrivalBtn ? selectedDepartureArrivalBtn.textContent : '';
    const recordTimeValue = document.getElementById('busStopTime').value;
    const recordTime = recordTimeValue ? new Date(recordTimeValue).toISOString() : new Date().toISOString();
    
    // 記録者名のみlocalStorageに保存
    localStorage.setItem('lastRecorderName', recorderName);
    // 気温、ODO、バッテリーのlocalStorageへの保存処理を削除

    const dataToSend = {
        recordType: 'busStop',
        recordTime: recordTime,
        projectName: document.getElementById('projectName').value.trim(),
        tripNumber: document.getElementById('tripNumber').value.trim(),
        direction: currentDirection,
        busStopName: currentBusStopInfo.busStopName,
        type: document.getElementById('busStopType').value,
        recorder: recorderName,
        temperature: temperature,
        odo: odo,
        battery: battery,
        passengersOn: document.getElementById('passengersOn').value.trim(),
        passengersOff: document.getElementById('passengersOff').value.trim(),
        isDelayed: document.getElementById('isDelayed').checked ? 'あり' : 'なし',
        delayDetails: document.getElementById('delayDetails').value.trim(),
        weather: weather,
        departureArrival: departureArrivalType
    };
    
    if (weather === 'その他') {
        dataToSend.weather_other = document.getElementById('weather_other').value.trim();
    }
    
    // 2. モーダルを即座に閉じる
    closeModal('busStopRecordModal');
    console.log("バス停の記録を送信します。"); // コンソールにメッセージを表示

    // 3. バックグラウンドで送信
    const formData = new FormData();
    for (const key in dataToSend) {
        formData.append(key, dataToSend[key]);
    }
    formData.append('sheetName', dataToSend.projectName);

    fetch(GAS_URL, { method: "POST", body: formData })
        .then(response => {
            if (!response.ok) throw new Error(`GAS request failed: ${response.status}`);
            return response.text();
        })
        .then(text => console.log("バス停記録 送信成功:", text))
        .catch(err => {
            console.error("バス停記録 送信失敗:", err);
        });
}

    // --- Area Info Modal Functions ---
    function openAreaInfoModal() {
        document.getElementById('areaName').value = '';
        document.querySelectorAll('#areaInfoModal input[type="checkbox"]').forEach(cb => cb.checked = false);
        loadCustomAreaInfoOptions('outbound');
        loadCustomAreaInfoOptions('inbound');
        showModal('areaInfoModal');
    }
    
    function openAreaInfoModalForEdit(layer) {
        pendingAreaLayer = layer;
        const properties = layer.feature.properties || {};

        document.getElementById('areaName').value = properties.name || '';

        const setCheckedValues = (name, values) => {
            if (!values || !Array.isArray(values)) return;
            document.querySelectorAll(`input[name="${name}"]`).forEach(cb => {
                cb.checked = values.includes(cb.value);
            });
        };

        document.querySelectorAll('#areaInfoModal input[type="checkbox"]').forEach(cb => cb.checked = false);
        
        loadCustomAreaInfoOptions('outbound');
        loadCustomAreaInfoOptions('inbound');

        if (properties.outbound) {
            setCheckedValues('area-shape1-outbound', properties.outbound.shape1);
            setCheckedValues('area-shape2-outbound', properties.outbound.shape2);
            setCheckedValues('area-shape3-outbound', properties.outbound.shape3);
            setCheckedValues('area-l4-status-outbound', properties.outbound.l4_status);
            setCheckedValues('area-mlit-extra-outbound', properties.outbound.mlit_extra);
        }
        if (properties.inbound) {
            setCheckedValues('area-shape1-inbound', properties.inbound.shape1);
            setCheckedValues('area-shape2-inbound', properties.inbound.shape2);
            setCheckedValues('area-shape3-inbound', properties.inbound.shape3);
            setCheckedValues('area-l4-status-inbound', properties.inbound.l4_status);
            setCheckedValues('area-mlit-extra-inbound', properties.inbound.mlit_extra);
        }

        showModal('areaInfoModal');
    }

    function addCustomAreaInfoOption(direction) {
        const input = document.getElementById(`newAreaInfoOptionInput-${direction}`);
        const value = input.value.trim();
        if (!value) {
            alert("項目名を入力してください。");
            return;
        }

        const container = document.getElementById(`area-mlit-extra-group-${direction}`);
        const existingOptions = Array.from(container.querySelectorAll('label'));
        if (existingOptions.some(label => label.textContent.trim() === value)) {
            alert("その項目は既に存在します。");
            return;
        }

        const label = document.createElement('label');
        // ★★★ この一行を追加 ★★★
        label.className = 'custom-area-option';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = `area-mlit-extra-${direction}`;
        checkbox.value = value;
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${value}`));
        container.appendChild(label);

        // ★★★ 保存先を方向ごとに分離 ★★★
        const key = `customAreaInfoOptions_${direction}`;
        const savedOptions = JSON.parse(localStorage.getItem(key) || '[]');
        if (!savedOptions.includes(value)) {
            savedOptions.push(value);
            localStorage.setItem(key, JSON.stringify(savedOptions));
        }

        input.value = '';
    }

    function loadCustomAreaInfoOptions(direction) {
        // ★★★ 読み込み元を方向ごとに分離 ★★★
        const key = `customAreaInfoOptions_${direction}`;
        const savedOptions = JSON.parse(localStorage.getItem(key) || '[]');
        const container = document.getElementById(`area-mlit-extra-group-${direction}`);
        if (!container) return;
        
        container.querySelectorAll('.custom-area-option').forEach(el => el.remove());

        savedOptions.forEach(value => {
            const label = document.createElement('label');
            label.className = 'custom-area-option';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = `area-mlit-extra-${direction}`;
            checkbox.value = value;
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(` ${value}`));
            container.appendChild(label);
        });
    }
    function confirmAreaInfo() {
        if (!pendingAreaLayer) return;

        const name = document.getElementById('areaName').value.trim();
        if (!name) {
            alert('エリア名を入力してください。');
            return;
        }

        const getCheckedValues = (name) => {
            const values = [];
            document.querySelectorAll(`input[name="${name}"]:checked`).forEach(cb => {
                values.push(cb.value);
            });
            return values;
        };

        const properties = {
            name: name,
            outbound: {
                shape1: getCheckedValues('area-shape1-outbound'),
                shape2: getCheckedValues('area-shape2-outbound'),
                shape3: getCheckedValues('area-shape3-outbound'),
                l4_status: getCheckedValues('area-l4-status-outbound'),
                mlit_extra: getCheckedValues('area-mlit-extra-outbound'),
            },
            inbound: {
                shape1: getCheckedValues('area-shape1-inbound'),
                shape2: getCheckedValues('area-shape2-inbound'),
                shape3: getCheckedValues('area-shape3-inbound'),
                l4_status: getCheckedValues('area-l4-status-inbound'),
                mlit_extra: getCheckedValues('area-mlit-extra-inbound'),
            }
        };
        
        const isNewLayer = !drawnItems.hasLayer(pendingAreaLayer);

        pendingAreaLayer.feature.properties = { ...pendingAreaLayer.feature.properties, ...properties };

        if (labelMap.has(pendingAreaLayer)) {
            pendingAreaLayer.unbindTooltip();
        }
        
        const tooltip = L.tooltip({
            permanent: true,
            direction: 'right',
            offset: [15, 0],
            className: 'speech-bubble-tooltip'
        }).setContent(name);

        let anchorLatLng;
        try {
            if (pendingAreaLayer.getBounds && pendingAreaLayer.getBounds().isValid()) {
                const bounds = pendingAreaLayer.getBounds();
                anchorLatLng = L.latLng(bounds.getCenter().lat, bounds.getEast());
            } else {
                anchorLatLng = pendingAreaLayer.getCenter();
            }
        } catch(err) {
            console.warn("Failed to get anchor for layer", pendingAreaLayer, err);
            if (pendingAreaLayer.getCenter) anchorLatLng = pendingAreaLayer.getCenter();
        }
        
        if (anchorLatLng) {
            tooltip.setLatLng(anchorLatLng);
            labelMap.set(pendingAreaLayer, tooltip);
            pendingAreaLayer.bindTooltip(tooltip);
            if (showLabels) pendingAreaLayer.openTooltip();
        }

        if (isNewLayer) {
            drawnItems.addLayer(pendingAreaLayer);
        }
        
        pendingAreaLayer = null;
        closeModal('areaInfoModal');
    }

    function cancelAreaInfo() {
        pendingAreaLayer = null;
        closeModal('areaInfoModal');
    }

    function openStyleEditor(layer, isEditFlow = false) {
        layerToStyle = layer;
        isEditingWorkflow = isEditFlow;
        
        const style = (layer.feature && layer.feature.properties) ? layer.feature.properties : layer.options;
        const isPolygon = layer instanceof L.Polygon;

        document.getElementById('lineColor').value = style.color || '#3388ff';
        document.getElementById('lineOpacity').value = style.opacity === undefined ? 1 : style.opacity;

        const fillColorControl = document.getElementById('fillColor').parentElement;
        const fillOpacityControl = document.getElementById('fillOpacity').parentElement;
        
        if (isPolygon) {
            fillColorControl.style.display = 'flex';
            fillOpacityControl.style.display = 'flex';
            document.getElementById('fillColor').value = style.fillColor || '#3388ff';
            document.getElementById('fillOpacity').value = style.fillOpacity === undefined ? 0.2 : style.fillOpacity;
        } else {
            fillColorControl.style.display = 'none';
            fillOpacityControl.style.display = 'none';
        }
        showModal('styleEditorModal');
    }

    function applyStyle() {
        if (!layerToStyle) return;

        const newStyle = {
            color: document.getElementById('lineColor').value,
            opacity: parseFloat(document.getElementById('lineOpacity').value)
        };

        if (layerToStyle instanceof L.Polygon) {
            newStyle.fillColor = document.getElementById('fillColor').value;
            newStyle.fillOpacity = parseFloat(document.getElementById('fillOpacity').value);
        }
        
        layerToStyle.setStyle(newStyle);

        if (!layerToStyle.feature) {
             layerToStyle.feature = { type: 'Feature', properties: {}, geometry: layerToStyle.toGeoJSON().geometry };
        }
        if (!layerToStyle.feature.properties) {
            layerToStyle.feature.properties = {};
        }
        
        Object.assign(layerToStyle.feature.properties, newStyle);

        closeModal('styleEditorModal');

        if (isEditingWorkflow && layerToStyle instanceof L.Polygon) {
            openAreaInfoModalForEdit(layerToStyle);
        }

        layerToStyle = null;
        isEditingWorkflow = false;
    }
    
    function attachInfoEditor(layer) {
        if (layer instanceof L.Polygon) {
            layer.on('click', function(e) {
                L.DomEvent.stopPropagation(e);
                openAreaInfoModalForEdit(this);
            });
        }
    }

    function openGlobalStyleEditor() {
        document.getElementById('globalLineColor').value = globalPolylineStyles.color;
        document.getElementById('globalFillColor').value = globalPolygonStyles.fillColor;
        document.getElementById('globalLineOpacity').value = globalPolylineStyles.opacity;
        document.getElementById('globalFillOpacity').value = globalPolygonStyles.fillOpacity;
        showModal('globalStyleModal');
    }

    function applyAndCloseGlobalStyleEditor() {
        closeModal('globalStyleModal');
    }


    // --- Pin Record/Load Functions ---
    function recordPins() {
        const pins = [];
        markerLayerGroup.eachLayer(layer => {
            if (layer instanceof L.Marker && layer._customData) {
                pins.push(layer._customData);
            }
        });

        if (pins.length === 0) {
            alert("保存するピンがありません。");
            return;
        }

        const projectName = document.getElementById('projectName').value.trim() || '未設定';
        const dateTimeStr = getCurrentJSTString('datetime_filename');
        const fileName = `${projectName}_ピン情報_${dateTimeStr}.json`;

        const blob = new Blob([JSON.stringify(pins, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
function openArrivalModal() {
    // モーダルを開く前に、案件名と便数が選択されているかチェック
    if (!validateTripInfo()) { // ★チェックする関数を変更
        return;
    }

    // 1. バス停のドロップダウンを生成
    const select = document.getElementById('arrivalBusStopSelect');
    select.innerHTML = '<option value="">バス停を選択してください</option>'; // 初期化
    const busStops = getBusStops();
    busStops.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
    });

    // 2. 他の入力欄をリセット
    document.getElementById('arrivalOdo').value = ''; // ★追加
    document.getElementById('arrivalBattery').value = ''; // ★追加
    document.getElementById('arrivalPassengersOff').value = '';
    document.getElementById('arrivalIsDelayed').checked = false;
    document.getElementById('arrivalDelayDetails').value = '';
	document.getElementById('arrivalRecordTime').value = getCurrentJSTString('datetime-local');

    // 3. モーダルを表示
    showModal('arrivalModal');
}

		function confirmArrivalRecord() {
    const busStopName = document.getElementById('arrivalBusStopSelect').value;
    if (!busStopName) {
        alert('バス停を選択してください。');
        return;
    }

    const recordTimeValue = document.getElementById('arrivalRecordTime').value;
    const recordTime = recordTimeValue ? new Date(recordTimeValue).toISOString() : new Date().toISOString();

    const dataToSend = {
        recordType: 'busStop',
        recordTime: recordTime, // 正しい時刻変数を参照
        projectName: document.getElementById('projectName').value.trim(),
        tripNumber: document.getElementById('tripNumber').value.trim(),
        direction: currentDirection,
        busStopName: busStopName,
        type: '手動',
        departureArrival: '到着',
        passengersOn: '',
        passengersOff: document.getElementById('arrivalPassengersOff').value.trim(),
        isDelayed: document.getElementById('arrivalIsDelayed').checked ? 'あり' : 'なし',
        delayDetails: document.getElementById('arrivalDelayDetails').value.trim(),
        recorder: '',
        temperature: '',
        odo: document.getElementById('arrivalOdo').value.trim(),
        battery: document.getElementById('arrivalBattery').value.trim(),
        weather: '',
        weather_other: ''
    };
    
    closeModal('arrivalModal');
    console.log("バス停到着の記録を送信します。");

    const formData = new FormData();
    for (const key in dataToSend) {
        formData.append(key, dataToSend[key]);
    }
    formData.append('sheetName', dataToSend.projectName);

    fetch(GAS_URL, { method: "POST", body: formData })
        .then(response => {
            if (!response.ok) throw new Error(`GAS request failed: ${response.status}`);
            return response.text();
        })
        .then(text => console.log("バス停到着記録 送信成功:", text))
        .catch(err => {
            console.error("バス停到着記録 送信失敗:", err);
        });
}
    function handlePinFiles(event) {
        const files = event.target.files;
        if (!files.length) return;

        if (markerLayerGroup.getLayers().length > 0) {
            if (!confirm("現在表示されているピンはクリアされます。よろしいですか？")) {
                event.target.value = '';
                return;
            }
        }
        markerLayerGroup.clearLayers();

        Array.from(files).forEach(file => {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const pins = JSON.parse(e.target.result);
                    if (Array.isArray(pins)) {
                        pins.forEach(pinData => {
                            const areaInfo = getAreaInfoFromPoint(L.latLng(parseFloat(pinData["緯度"]), parseFloat(pinData["経度"])));
                            createAndAddMarker(pinData, areaInfo);
                        });
                    } else {
                        throw new Error("JSON file is not an array of pins.");
                    }
                } catch(err) {
                    alert(`ファイル「${file.name}」の読み込みに失敗しました: ${err.message}`);
                    console.error(err);
                }
            };
            reader.readAsText(file);
        });
        
        event.target.value = '';
    }
	document.addEventListener('DOMContentLoaded', (event) => {
    const toggleBtn = document.getElementById('toggle-reasons-btn');
    if (toggleBtn) {
        toggleBtn.addEventListener('click', () => {
            const reasonContainer = document.getElementById('reason-major-buttons');
            if (!reasonContainer) return;

            const allDetails = reasonContainer.querySelectorAll('details');
            if (allDetails.length === 0) return;

            // 1つでも閉じているアコーディオンがあれば「全て開く」動作、そうでなければ「全て閉じる」動作
            const shouldOpen = Array.from(allDetails).some(d => !d.open);

            allDetails.forEach(detail => {
                detail.open = shouldOpen;
            });

            // ボタンのテキストを切り替え
            toggleBtn.textContent = shouldOpen ? '全て閉じる' : '全て開く';
        });
    }
});
function validateTripInfo() {
    const projectNameInput = document.getElementById('projectName');
    const tripNumberInput = document.getElementById('tripNumber');
    const directionButtons = document.querySelectorAll('.direction-button');

    // 事前に警告表示をクリア
    projectNameInput.classList.remove('warning');
    tripNumberInput.classList.remove('warning');
    directionButtons.forEach(btn => btn.classList.remove('warning'));

    // ★★★ 往路・復路のチェックを追加 ★★★
    if (!currentDirection) {
        alert("「往路」または「復路」を選択してください。");
        directionButtons.forEach(btn => btn.classList.add('warning'));
        return false;
    }
    if (!projectNameInput.value.trim()) {
        alert("案件名を入力してください。");
        projectNameInput.classList.add('warning');
        return false;
    }
    if (!tripNumberInput.value) {
        alert("便数を選択してください。");
        tripNumberInput.classList.add('warning');
        return false;
    }
    return true;
}

/**
 * ★★★ ここからが置き換えるコードです ★★★
 */
function downloadPinsAsXLSX() {
    const pins = [];
    markerLayerGroup.eachLayer(layer => {
        if (layer instanceof L.Marker && layer._customData) {
            pins.push(layer._customData);
        }
    });

    if (pins.length === 0) {
        alert("保存するピンがありません。");
        return;
    }
    
    // 保存用にピンのデータを加工する
    const processedPins = pins.map(pin => {
        const newPin = { ...pin };

        // --- ここからが修正箇所 ---
        // ピンのデータ形式に応じて日付と時刻を処理する
        if (newPin["記録日"] && newPin["記録時間"]) {
            // 既に「記録日」「記録時間」があれば、何もしない
            delete newPin["記録日時"]; // 不要なフィールドは削除
        } else if (newPin["記録日時"]) {
            // 「記録日時」しかない場合（新規作成されたピンなど）
            const recordDateTime = new Date(newPin["記録日時"]);
            if (recordDateTime && !isNaN(recordDateTime.getTime())) {
                const yyyy = recordDateTime.getFullYear();
                const mm = String(recordDateTime.getMonth() + 1).padStart(2, '0');
                const dd = String(recordDateTime.getDate()).padStart(2, '0');
                newPin["記録日"] = `${yyyy}/${mm}/${dd}`;

                const hh = String(recordDateTime.getHours()).padStart(2, '0');
                const mi = String(recordDateTime.getMinutes()).padStart(2, '0');
                const ss = String(recordDateTime.getSeconds()).padStart(2, '0');
                newPin["記録時間"] = `${hh}:${mi}:${ss}`;
            } else {
                newPin["記録日"] = "日付エラー";
                newPin["記録時間"] = "時刻エラー";
            }
            delete newPin["記録日時"]; // 分割元のフィールドは削除
        } else {
            // 日付情報が一切ない場合
            newPin["記録日"] = "日付なし";
            newPin["記録時間"] = "時刻なし";
        }
        // --- ここまでが修正箇所 ---

        // エリア情報を最新化
        const latlng = L.latLng(parseFloat(newPin["緯度"]), parseFloat(newPin["経度"]));
        const areaInfo = getAreaInfoFromPoint(latlng);
        const directionalArea = getDirectionalAreaInfo(areaInfo, newPin['往復方向']);
        const shapePresence = getShapePresence(directionalArea.shape1);

        newPin["エリア番号"] = areaInfo ? areaInfo.name : "";
        newPin["道路形状1"] = directionalArea.shape1;
        if (newPin["道路形状2"] !== "交差点付近") {
            newPin["道路形状2"] = directionalArea.shape2;
        }
        newPin["道路形状3"] = directionalArea.shape3;
        newPin["L4区間内外"] = directionalArea.l4_status;
        newPin["国交省外"] = directionalArea.mlit_extra;
        Object.assign(newPin, shapePresence);

        return newPin;
    });

    if (processedPins.length === 0) {
        alert("処理できるピンがありませんでした。");
        return;
    }

    const headers = Object.keys(processedPins[0] || {});
    const dataRows = processedPins.map(pin => {
        return headers.map(header => pin[header]);
    });

    const sheetData = [
        ["介入時刻記録シート"],
        headers,
        ...dataRows
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(sheetData);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "ピン情報");

    const projectName = document.getElementById('projectName').value.trim() || '未設定';
    const dateTimeStr = getCurrentJSTString('datetime_filename');
    const fileName = `${projectName}_ピン情報_${dateTimeStr}.xlsx`;

    XLSX.writeFile(workbook, fileName);
}
/**
 * ★★★ ここまでが置き換えるコードです ★★★
 */
/**
 * ★★★ ここからが置き換えるコードです ★★★
 */
function handleXLSXFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (markerLayerGroup.getLayers().length > 0) {
        if (!confirm("現在表示されているピンはクリアされます。よろしいですか？")) {
            event.target.value = '';
            return;
        }
    }
    markerLayerGroup.clearLayers();

    const reader = new FileReader();
    reader.onload = function(e) {
        const data = e.target.result;
        try {
            const workbook = XLSX.read(data, { type: 'binary', cellDates: true });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];

            let pinsData;
            const cellA2 = worksheet['A2'];
            if (cellA2 && cellA2.v === 'UUID') {
                console.log("ヘッダーが2行目にある形式のファイルを読み込みます。");
                pinsData = XLSX.utils.sheet_to_json(worksheet, { range: 1 }); 
            } else {
                console.log("ヘッダーが1行目にある形式のファイルを読み込みます。");
                pinsData = XLSX.utils.sheet_to_json(worksheet);
            }

            if (!Array.isArray(pinsData) || pinsData.length === 0) {
                 throw new Error("XLSXファイルに有効なデータが見つかりませんでした。");
            }
            
            // --- ここからが修正箇所 ---
            // 読み込んだデータに「記録日」と「記録時間」があれば、それを結合して「記録日時」フィールドを作成する
            const transformedPinsData = pinsData.map(pin => {
                if (pin["記録日"] && pin["記録時間"]) {
                    // Excelの日付シリアル値からDateオブジェクトに変換されている場合と、文字列の場合の両方を考慮
                    const recordDate = new Date(pin["記録日"]);
                    const recordTime = new Date(pin["記録時間"]);

                    if (!isNaN(recordDate.getTime()) && !isNaN(recordTime.getTime())) {
                        // 年月日を「記録日」から、時分秒を「記録時間」から取得
                        const y = recordDate.getFullYear();
                        const m = recordDate.getMonth();
                        const d = recordDate.getDate();
                        const h = recordTime.getHours();
                        const min = recordTime.getMinutes();
                        const s = recordTime.getSeconds();
                        
                        // 1つのDateオブジェクトに結合
                        const combinedDate = new Date(y, m, d, h, min, s);
                        pin["記録日時"] = combinedDate.toISOString();
                    }
                }
                return pin;
            });
            // --- ここまでが修正箇所 ---

            let loadedCount = 0;
            // 変換後のデータを使ってピンを作成
            transformedPinsData.forEach(pinData => {
                if (pinData.hasOwnProperty('緯度') && pinData.hasOwnProperty('経度')) {
                    
                    const majorReason = (pinData["介入事由（大項目）"] || "").trim();
                    const isNonIntervention = majorReason === "介入なし";
                    let shouldLoad = false;

                    switch (pinLoadFilter) {
                        case '全て':
                            shouldLoad = true;
                            break;
                        case '介入のみ':
                            shouldLoad = !isNonIntervention;
                            break;
                        case '非介入のみ':
                            shouldLoad = isNonIntervention;
                            break;
                    }

                    if (shouldLoad) {
                        const lat = parseFloat(pinData['緯度']);
                        const lng = parseFloat(pinData['経度']);
                        if (!isNaN(lat) && !isNaN(lng)) {
                            const latlng = L.latLng(lat, lng);
                            const areaInfo = getAreaInfoFromPoint(latlng);
                            createAndAddMarker(pinData, areaInfo);
                            loadedCount++;
                        }
                    }
                }
            });
            alert(`「${file.name}」から ${loadedCount} 件のピンを読み込みました。（フィルター: ${pinLoadFilter}）`);

        } catch (err) {
            alert(`XLSXファイルの読み込みに失敗しました: ${err.message}`);
            console.error(err);
            markerLayerGroup.clearLayers();
        }
    };
    reader.readAsBinaryString(file);
    event.target.value = '';
}
/**
 * ★★★ ここまでが置き換えるコードです ★★★
 */
/**
     * ★★★ 新規追加 ★★★
     * ピン読み込みの種類を選択するモーダルを開く関数
     */
    function openPinFilterModal() {
        showModal('pinFilterModal');
    }

    /**
     * ★★★ 新規追加 ★★★
     * フィルターの種類をセットして、ファイル選択ダイアログを開く関数
     */
    function startPinLoad(filterType) {
        pinLoadFilter = filterType;
        closeModal('pinFilterModal');
        document.getElementById('xlsxFileInput').click();
    }
	
	function openModalForEdit(markerId) {
        let targetMarker = null;
        markerLayerGroup.eachLayer(layer => {
            if (L.stamp(layer) === markerId) {
                targetMarker = layer;
            }
        });

        if (!targetMarker) {
            console.error("編集対象のマーカーが見つかりません:", markerId);
            return;
        }

        editingPinData = targetMarker._customData;
        
        const recordDate = new Date(editingPinData["記録日時"]);
        document.getElementById('interventionRecordTime').value = getCurrentJSTString('datetime-local', recordDate);
        document.getElementById('freeMemo').value = editingPinData["メモ"] || "";

        buttonStates = {};
        if (editingPinData["介入事由（大項目）"]) {
            buttonStates.reason = {
                major: editingPinData["介入事由（大項目）"],
                minors: editingPinData["介入事由（中項目）"] ? editingPinData["介入事由（中項目）"].split(' : ') : []
            };
        }
        
        createDynamicFields('dynamicFields', fields);
        
        document.querySelectorAll('#customModal .position-grid div[data-pos].selected').forEach(e => e.classList.remove('selected'));
        if (editingPinData["相手位置"]) {
            const posDiv = document.querySelector(`#customModal .position-grid div[data-pos="${editingPinData["相手位置"]}"]`);
            if (posDiv) posDiv.classList.add('selected');
        }
        
        document.querySelector('#customModalTitle').textContent = '記録を編集してください';
		showModal('customModal');
        
        resetDetailsTab();

        // ★★★ この部分を、全ての処理の最後に実行されるよう修正しました ★★★
        setTimeout(() => {
            if (document.getElementById('isIntersectionNearby')) {
                // 保存されている「道路形状②」が「交差点付近」であれば、チェックを入れる
                const isNearIntersection = (editingPinData["道路形状2"] === "交差点付近");
                document.getElementById('isIntersectionNearby').checked = isNearIntersection;
            }
        }, 0);
    }
    </script>
	
<div id="customModal" class="modal-overlay">
    <div class="modal-content-box">
        <!-- Header -->
        <div id="modal-header-controls">
            <div class="header-buttons-left">
                <button onclick="confirmModal()" class="ok-button" id="mainModalOkButton">OK</button>
                <button onclick="closeModal('customModal')" class="cancel-button">キャンセル</button>
            </div>
            <h3 id="customModalTitle">介入記録を入力してください</h3>
            <div class="header-buttons-right">
                <button onclick="openNonInterventionModal()" class="cancel-button">非介入はこちら</button>
            </div>
        </div>

        <!-- New 2-Column Body -->
        <div class="modal-body-grid">
            <div class="modal-column">
                <div class="modal-section">
                    <p class="modal-section-title">介入事由（国交省）</p>
                    <div id="reason-tab-nav" class="tab-nav">
                        </div>
                    <div id="reason-tab-content">
                        </div>
                    <div id="selectedReasonDisplay" style="margin-top: 10px;">未選択</div>
                    <div class="major-reason-input-group">
                        <input type="text" id="newMajorReasonInput" placeholder="新しい大項目名">
                        <button onclick="addCustomMajorReason()">追加</button>
                        <button onclick="removeCustomMajorReason()" title="選択されているカスタム大項目を削除します" style="background-color: #dc3545; color: white;">選択削除</button>
                    </div>
                </div>
            </div>

            <div class="modal-column">
                <div class="modal-section">
                    <p class="modal-section-title">状況詳細（自車の状態は国交省、それ以外は国交省外で必要であれば記載）</p>
                    <div class="tab-nav" id="details-tab-nav">
						<button class="tab-button active" onclick="showTab('ego', this)">自車の状態</button>
                        <button class="tab-button" onclick="showTab('factor', this)">要因</button>
                        <button class="tab-button" onclick="showTab('target', this)">相手の動き</button>
                        <button class="tab-button" onclick="showTab('target-pos', this)">相手の位置</button>
                    </div>
                    <div class="tab-content" id="details-tab-content">
                        <div id="tab-pane-factor" class="tab-pane"></div>
                        <div id="tab-pane-ego" class="tab-pane active"></div>
                        <div id="tab-pane-target" class="tab-pane"></div>
                        <div id="tab-pane-target-pos" class="tab-pane">
                            <div class="position-grid" style="display:grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(5, auto); grid-auto-flow: column; gap:4px;">
                                <div data-pos="左 前 （ 遠 ）" onclick="selectPosition(this)">左 前 （ 遠 ）</div>
                                <div data-pos="左 前" onclick="selectPosition(this)">左 前</div>
                                <div data-pos="左 面" onclick="selectPosition(this)">左 面</div>
                                <div data-pos="左 後" onclick="selectPosition(this)">左 後</div>
                                <div data-pos="左 後 （ 遠 ）" onclick="selectPosition(this)">左 後 （ 遠 ）</div>
                                <div data-pos="正 面 （ 遠 ）" onclick="selectPosition(this)">正 面 （ 遠 ）</div>
                                <div data-pos="正 面" onclick="selectPosition(this)">正 面</div>
                                <div id="self-vehicle-cell">自 車 両</div>
                                <div data-pos="後 方" onclick="selectPosition(this)">後 方</div>
                                <div data-pos="後 方 （ 遠 ）" onclick="selectPosition(this)">後 方 （ 遠 ）</div>
                                <div data-pos="右 前 （ 遠 ）" onclick="selectPosition(this)">右 前 （ 遠 ）</div>
                                <div data-pos="右 前" onclick="selectPosition(this)">右 前</div>
                                <div data-pos="右 面" onclick="selectPosition(this)">右 面</div>
                                <div data-pos="右 後" onclick="selectPosition(this)">右 後</div>
                                <div data-pos="右 後 （ 遠 ）" onclick="selectPosition(this)">右 後 （ 遠 ）</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-section">
                     <p class="modal-section-title">介入操作（国交省）</p>
                     <div id="operation-container"></div>
                </div>
                <div class="modal-section basic-info-section">
                    <p class="modal-section-title">基本情報</p>
                    <div class="modal-field">
                        <p><strong>記録日時</strong></p>
                        <input type="datetime-local" id="interventionRecordTime" step="1" style="padding: 4px; flex-grow: 1;">
                    </div>
						<div class="modal-field">
                        <p><strong>メモ</strong></p>
                        <div style="flex-grow: 1;">
                            <textarea id="freeMemo" rows="2" style="width: 100%; display: block; box-sizing: border-box;"></textarea>
                        </div>
                    </div>
                    <div class="modal-field">
                        <p><strong>交差点付近</strong></p>
                        <div>
                            <label>
                                <input type="checkbox" id="isIntersectionNearby">
                                交差点30m以内（停止線等から30m以内）
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="modal-footer">
            <div class="favorite-buttons-container">
                <button onclick="openSaveFavoriteModal()">お気に入り登録</button>
            </div>
            <button onclick="confirmModal()" class="ok-button" id="mainModalOkButtonFooter">OK</button>
            <button onclick="closeModal('customModal')" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="nonInterventionModal" class="modal-overlay">
    <div class="modal-content-box">
        <h3>介入なし（非介入）記録</h3>

        <div class="non-intervention-field">
            <p>メモ</p>
            <textarea id="nonInterventionMemo" rows="5"></textarea>
        </div>

         <div class="non-intervention-field">
            <p>ヒヤリ・メモの種別</p>
             <label><input type="checkbox" id="nonInterventionHiyari" name="nonInterventionType"> ヒヤリ</label>
             <label><input type="checkbox" id="nonInterventionMemoOnly" name="nonInterventionType"> メモのみ</label>
        </div>

        <div class="non-intervention-field">
            <p>信号検知</p>
            <div class="signal-detection-options">
                <label><input type="radio" name="signalDetection" value="検知できていた"> 検知できていた</label>
                <label><input type="radio" name="signalDetection" value="検知できていなかった"> 検知できていなかった</label>
                <label><input type="radio" name="signalDetection" value="その他" onclick="toggleSignalOtherMemo(true)"> その他</label>
                <input type="text" id="signalOtherMemo" placeholder="その他詳細" style="display: none;">
            </div>
        </div>
		
	    <div class="non-intervention-field">
            <p>急減速・急停止</p>
            <div class="signal-detection-options">
                <label><input type="radio" name="suddenBraking" value="急減速"> 急減速</label>
                <label><input type="radio" name="suddenBraking" value="急停止"> 急停止</label>
                <label><input type="radio" name="signalDetection" value="その他" onclick="toggleSignalOtherMemo(true)"> その他</label>
                <input type="text" id="signalOtherMemo" placeholder="その他詳細" style="display: none;">
                </div>
        </div>	

        <div id="nonInterventionSelectedLocation" style="margin-top: 10px; font-style: italic; color: #555;"></div>


        <div class="modal-footer">
            <button onclick="closeNonInterventionModal(true)" class="cancel-button">介入記録へ戻る</button>
            <button onclick="confirmNonInterventionModal()" id="confirmNonInterventionButton" class="ok-button">記録する</button>
            <button onclick="closeNonInterventionModal(false)" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="minorReasonModal" class="modal-overlay">
    <div class="modal-content-box">
        <div id="minorReasonModalHeader" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
             <h3 id="minorReasonModalTitle"></h3>
             <button onclick="removeSelectedMinorReasons()" class="cancel-button">選択項目を削除</button>
        </div>

        <div class="modal-field">
            <p><strong>中項目を選択・追加してください</strong></p>
            <div id="minorReasonButtonsContainer" class="multi-select"></div>
        </div>
        <div class="modal-field">
             <div class="modal-input-group">
                <input type="text" id="minorReasonInput" placeholder="新しい中項目名">
                <button onclick="addCustomMinorReason()">新規追加</button>
             </div>
        </div>

        <div class="modal-footer">
            <button id="minorReasonOkButton" onclick="confirmMinorReasonSelection()" class="ok-button">OK</button>
            <button onclick="closeMinorReasonModalAndReset()" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="mlitFactorModal" class="modal-overlay">
    <div class="modal-content-box">
        <h3 id="mlitFactorModalTitle">国交省用要因の選択</h3>
        <div class="modal-field">
            <p><strong>新規追加した中項目に対応する国交省用要因を一つ選択してください</strong></p>
            <div id="mlitFactorButtonsContainer" class="multi-select" style="display: flex; flex-wrap: wrap; gap: 5px;">
            </div>
        </div>
        <div class="modal-footer">
            <button onclick="confirmMlitFactorSelection()" class="ok-button">決定</button>
            <button onclick="closeModal('mlitFactorModal')" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="busStopRecordModal" class="modal-overlay">
    <div class="modal-content-box">
        <h3 id="busStopRecordModalTitle">バス停通過記録</h3>
        <div class="modal-field">
            <p>記録日時</p>
            <input type="datetime-local" id="busStopTime" step="1" style="padding: 8px; font-size: 16px; flex-grow: 1;">
        </div>
        <div class="modal-field">
            <p>種別</p>
            <select id="busStopType" style="padding: 8px; font-size: 16px;">
                <option value="自動" selected>自動</option>
                <option value="手動">手動</option>
                <option value="運休">運休</option>
            </select>
        </div>
        <div class="modal-field">
            <p>発着</p>
            <div id="departure-arrival-buttons">
                <button onclick="selectDepartureArrival(this)">出発</button>
                <button onclick="selectDepartureArrival(this)">到着</button>
            </div>
        </div>
        <div class="modal-field">
            <p>記録者</p>
            <input type="text" id="recorder" placeholder="記録者名">
        </div>
        <div class="modal-field">
            <p>天候</p>
            <div>
                <div id="weather-buttons">
                    <button onclick="selectWeather(this, '晴れ')">晴れ</button>
                    <button onclick="selectWeather(this, '曇り')">曇り</button>
                    <button onclick="selectWeather(this, '降雨')">降雨</button>
                    <button onclick="selectWeather(this, '降雪')">降雪</button>
                    <button onclick="selectWeather(this, '堆雪')">堆雪</button>
                    <button onclick="selectWeather(this, 'キリ')">キリ</button>
                </div>
                <div id="weather_other_field" style="display:none; margin-top: 5px;">
                    <input type="text" id="weather_other" placeholder="天候詳細">
                </div>
            </div>
        </div>
        <div class="modal-field">
            <p>気温</p>
            <input type="text" id="temperature" placeholder="例: 25（℃：数字のみ記載）">
        </div>
        <div class="modal-field">
            <p>ODOメータ</p>
            <input type="text" id="odo" placeholder="例: 12345（km：数字のみ記載）">
        </div>
        <div class="modal-field">
            <p>バッテリー</p>
            <input type="text" id="battery" placeholder="例: 80（%：数字のみ記載）">
        </div>
        <div class="modal-field">
            <p>乗車人数</p>
            <input type="number" id="passengersOn" placeholder="0">
        </div>
        <div class="modal-field">
            <p>降車人数</p>
            <input type="number" id="passengersOff" placeholder="0">
        </div>
        <div class="modal-field">
            <p>遅延</p>
            <label><input type="checkbox" id="isDelayed"> 遅延あり</label>
        </div>
        <div class="modal-field">
            <p>遅延・早発詳細</p>
            <textarea id="delayDetails" rows="2" style="width: 100%;"></textarea>
        </div>

        <div class="modal-footer">
            <button id="busStopOkButton" onclick="confirmBusStopRecord()" class="ok-button">記録する</button>
            <button onclick="closeModal('busStopRecordModal')" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="saveFavoriteModal" class="modal-overlay">
    <div class="modal-content-box">
        <h3>お気に入りとして保存</h3>
        <div class="modal-field">
            <p><strong>お気に入り名</strong></p>
            <input type="text" id="favoriteNameInput" placeholder="例: 右折時の対向車検知遅れ">
        </div>
        <div class="modal-footer">
            <button onclick="saveFavoritePreset()" class="ok-button">保存</button>
            <button onclick="closeModal('saveFavoriteModal')" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="areaInfoModal" class="modal-overlay">
    <div class="modal-content-box">
        <h3>エリア情報設定</h3>
        <div class="modal-field">
            <p><strong>エリア名</strong></p>
            <input type="text" id="areaName" placeholder="例: ○○交差点" style="flex-grow:1;">
        </div>

        <div style="display: flex; gap: 20px;">
            <!-- 往路セクション -->
<div class="area-info-section" style="flex: 1;">
    <h4>往路</h4>
    <div class="shape-group"><p>道路形状①</p>
        <label><input type="checkbox" name="area-shape1-outbound" value="信号">信号</label>
        <label><input type="checkbox" name="area-shape1-outbound" value="横断歩道">横断歩道</label>
        <label><input type="checkbox" name="area-shape1-outbound" value="バス停">バス停</label>
        <label><input type="checkbox" name="area-shape1-outbound" value="歩者分離されている">歩者分離</label>
    </div>
    <div class="shape-group"><p>道路形状②</p>
            <!-- ★★★ name属性を全て-outboundに修正 ★★★ -->
            <label><input type="checkbox" name="area-shape2-outbound" value="交差点内">交差点内</label>
            <label><input type="checkbox" name="area-shape2-outbound" value="交差点付近">交差点付近</label>
            <label><input type="checkbox" name="area-shape2-outbound" value="単路">単路</label>
            <label><input type="checkbox" name="area-shape2-outbound" value="単路（トンネル）">トンネル</label>
            <label><input type="checkbox" name="area-shape2-outbound" value="単路（橋）">橋</label>
            <label><input type="checkbox" name="area-shape2-outbound" value="ロータリー">ロータリー</label>
            <label><input type="checkbox" name="area-shape2-outbound" value="踏切">踏切</label>
            <label><input type="checkbox" name="area-shape2-outbound" value="その他">その他</label>
    </div>
    <div class="shape-group"><p>道路形状③</p>
            <!-- ★★★ name属性を全て-outboundに修正 ★★★ -->
            <label><input type="checkbox" name="area-shape3-outbound" value="右カーブ">右カーブ</label>
            <label><input type="checkbox" name="area-shape3-outbound" value="左カーブ">左カーブ</label>
            <label><input type="checkbox" name="area-shape3-outbound" value="直線">直線</label>
            <label><input type="checkbox" name="area-shape3-outbound" value="坂道">坂道</label>
            <label><input type="checkbox" name="area-shape3-outbound" value="その他">その他</label>
    </div>
    <div class="shape-group"><p>L4区間内外</p>
            <!-- ★★★ name属性を全て-outboundに修正 ★★★ -->
            <label><input type="checkbox" name="area-l4-status-outbound" value="L4想定区間内">L4想定区間内</label>
            <label><input type="checkbox" name="area-l4-status-outbound" value="L4想定区間外">L4想定区間外</label>
            <label><input type="checkbox" name="area-l4-status-outbound" value="実証走行ルート外">実証走行ルート外</label>
    </div>
    <div class="shape-group" id="area-mlit-extra-group-outbound"><p>国交省報告外要因</p>
            <!-- ★★★ name属性を全て-outboundに修正 ★★★ -->
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="路車協調あり">路車協調</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="信号連携有り">信号連携</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="右折">右折</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="左折">左折</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="上り坂">上り坂</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="下り坂">下り坂</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="急勾配">急勾配</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="片側二車線以上">片側2車線+</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="一通">一通</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="地物が少ない">地物少</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="舗装されていない">未舗装</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="狭路">狭路</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="中央分離帯あり">中央分離帯</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="五差路以上">5差路+</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="矢羽根式信号">矢羽根信号</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="バスベイ">バスベイ</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="路肩に停車">路肩に停車</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="発進">発進</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="到着">到着</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="急カーブ">急カーブ</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="死角がある">死角がある</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="駐車場からの出入りが多い">駐車場からの出入りが多い</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="歩行者と距離が近い">歩行者と距離が近い</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="自転車専用レーン有">自転車専用レーン</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="右左折等専用レーン有">右左折等専用レーン有</label>
            <label><input type="checkbox" name="area-mlit-extra-outbound" value="植栽がはみ出ている">植栽がはみ出ている</label>
        <!-- カスタムオプションがここに追加される -->
    </div>
    <div><input type="text" id="newAreaInfoOptionInput-outbound" placeholder="新しい要因を追加"><button onclick="addCustomAreaInfoOption('outbound')">追加</button></div>
</div>
            <!-- 復路セクション -->
            <div class="area-info-section" style="flex: 1;">
                <h4>復路</h4>
                <div class="shape-group"><p>道路形状①</p>
                    <label><input type="checkbox" name="area-shape1-inbound" value="信号">信号</label>
                    <label><input type="checkbox" name="area-shape1-inbound" value="横断歩道">横断歩道</label>
                    <label><input type="checkbox" name="area-shape1-inbound" value="バス停">バス停</label>
                    <label><input type="checkbox" name="area-shape1-inbound" value="歩者分離されている">歩者分離</label>
                </div>
                <div class="shape-group"><p>道路形状②</p>
                        <label><input type="checkbox" name="area-shape2-inbound" value="交差点内">交差点内</label>
                        <label><input type="checkbox" name="area-shape2-inbound" value="交差点付近">交差点付近</label>
                        <label><input type="checkbox" name="area-shape2-inbound" value="単路">単路</label>
                        <label><input type="checkbox" name="area-shape2-inbound" value="単路（トンネル）">トンネル</label>
                        <label><input type="checkbox" name="area-shape2-inbound" value="単路（橋）">橋</label>
                        <label><input type="checkbox" name="area-shape2-inbound" value="ロータリー">ロータリー</label>
                        <label><input type="checkbox" name="area-shape2-inbound" value="踏切">踏切</label>
                        <label><input type="checkbox" name="area-shape2-inbound" value="その他">その他</label>
                </div>
                <div class="shape-group"><p>道路形状③</p>
                        <label><input type="checkbox" name="area-shape3-inbound" value="右カーブ">右カーブ</label>
                        <label><input type="checkbox" name="area-shape3-inbound" value="左カーブ">左カーブ</label>
                        <label><input type="checkbox" name="area-shape3-inbound" value="直線">直線</label>
                        <label><input type="checkbox" name="area-shape3-inbound" value="坂道">坂道</label>
                        <label><input type="checkbox" name="area-shape3-inbound" value="その他">その他</label>
                </div>
                <div class="shape-group"><p>L4区間内外</p>
                        <label><input type="checkbox" name="area-l4-status-inbound" value="L4想定区間内">L4想定区間内</label>
                        <label><input type="checkbox" name="area-l4-status-inbound" value="L4想定区間外">L4想定区間外</label>
                        <label><input type="checkbox" name="area-l4-status-inbound" value="実証走行ルート外">実証走行ルート外</label>
                </div>
                <div class="shape-group" id="area-mlit-extra-group-inbound"><p>国交省報告外要因</p>
				                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="路車協調あり">路車協調</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="信号連携有り">信号連携</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="右折">右折</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="左折">左折</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="上り坂">上り坂</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="下り坂">下り坂</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="急勾配">急勾配</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="片側二車線以上">片側2車線+</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="一通">一通</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="地物が少ない">地物少</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="舗装されていない">未舗装</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="狭路">狭路</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="中央分離帯あり">中央分離帯</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="五差路以上">5差路+</label>
                        <label><input type="checkbox" name="area-mlit-extra-inbound" value="矢羽根式信号">矢羽根信号</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="バスベイ">バスベイ</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="路肩に停車">路肩に停車</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="発進">発進</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="到着">到着</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="急カーブ">急カーブ</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="死角がある">死角がある</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="駐車場からの出入りが多い">駐車場からの出入りが多い</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="歩行者と距離が近い">歩行者と距離が近い</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="自転車専用レーン有">自転車専用レーン</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="右左折等専用レーン有">右左折等専用レーン有</label>
						<label><input type="checkbox" name="area-mlit-extra-inbound" value="植栽がはみ出ている">植栽がはみ出ている</label>
                    <!-- カスタムオプションがここに追加される -->
                </div>
                <div><input type="text" id="newAreaInfoOptionInput-inbound" placeholder="新しい要因を追加"><button onclick="addCustomAreaInfoOption('inbound')">追加</button></div>
            </div>
        </div>
        <div class="modal-footer">
            <button onclick="confirmAreaInfo()" class="ok-button">OK</button>
            <button onclick="cancelAreaInfo()" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="styleEditorModal" class="modal-overlay">
    <div class="modal-content-box">
        <h3>個別スタイル編集</h3>
        <div class="style-control">
            <label for="lineColor">線の色</label>
            <input type="color" id="lineColor">
        </div>
        <div class="style-control">
            <label for="lineOpacity">線の不透明度</label>
            <input type="range" id="lineOpacity" min="0" max="1" step="0.1">
        </div>
        <div class="style-control">
            <label for="fillColor">塗りつぶし色</label>
            <input type="color" id="fillColor">
        </div>
        <div class="style-control">
            <label for="fillOpacity">塗りつぶし不透明度</label>
            <input type="range" id="fillOpacity" min="0" max="1" step="0.1">
        </div>
        <div class="modal-footer">
            <button onclick="applyStyle()" class="ok-button">適用</button>
            <button onclick="closeModal('styleEditorModal')" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="globalStyleModal" class="modal-overlay">
    <div class="modal-content-box">
        <h3>一括スタイル編集</h3>
        <div class="style-control">
            <label for="globalLineColor">線の色（全種）</label>
            <input type="color" id="globalLineColor">
        </div>
        <div class="style-control">
            <label for="globalLineOpacity">線の不透明度（全種）</label>
            <input type="range" id="globalLineOpacity" min="0" max="1" step="0.1">
        </div>
        <div class="style-control">
            <label for="globalFillColor">塗りつぶし色（エリア）</label>
            <input type="color" id="globalFillColor">
        </div>
        <div class="style-control">
            <label for="globalFillOpacity">塗りつぶし不透明度（エリア）</label>
            <input type="range" id="globalFillOpacity" min="0" max="1" step="0.1">
        </div>
        <div class="modal-footer">
            <button onclick="applyAndCloseGlobalStyleEditor()" class="ok-button">適用</button>
            <button onclick="closeModal('globalStyleModal')" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>

<div id="loadChoiceModal" class="modal-overlay">
    <div class="modal-content-box" style="text-align: center;">
        <h3>読み込むファイル形式を選択</h3>
        <div style="display: flex; justify-content: center; gap: 20px; margin: 20px 0;">
            <button onclick="document.getElementById('jsonFileInput').click()" class="ok-button" style="padding: 10px 20px;">JSON (.json)</button>
            <button onclick="document.getElementById('kmlFileInput').click()" class="ok-button" style="padding: 10px 20px;">KML/KMZ (.kml, .kmz)</button>
        </div>
        <div class="modal-footer">
            <button onclick="closeModal('loadChoiceModal')" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>
<div id="arrivalModal" class="modal-overlay">
    <div class="modal-content-box">
        <h3 id="arrivalModalTitle">バス停到着記録</h3>
		<div class="modal-field">
            <p><strong>記録日時</strong></p>
            <input type="datetime-local" id="arrivalRecordTime" step="1" style="padding: 8px; font-size: 16px; flex-grow: 1;">
        </div>
        <div class="modal-field">
            <p><strong>バス停</strong></p>
            <select id="arrivalBusStopSelect" style="padding: 8px; font-size: 16px; width: 100%;"></select>
        </div>
        <div class="modal-field">
            <p><strong>ODDメータ</strong></p>
            <input type="text" id="arrivalOdo" placeholder="最終バス停のみ記載" style="padding: 8px; font-size: 16px;">
        </div>
        <div class="modal-field">
            <p><strong>バッテリー</strong></p>
            <input type="text" id="arrivalBattery" placeholder="最終バス停のみ記載" style="padding: 8px; font-size: 16px;">
        </div>
        <div class="modal-field">
            <p><strong>降車人数</strong></p>
            <input type="number" id="arrivalPassengersOff" placeholder="0" style="padding: 8px; font-size: 16px;">
        </div>
        <div class="modal-field">
            <p><strong>遅延</strong></p>
            <label><input type="checkbox" id="arrivalIsDelayed"> 遅延あり</label>
        </div>
        <div class="modal-field">
            <p><strong>遅延・早発詳細</strong></p>
            <textarea id="arrivalDelayDetails" rows="3" style="width: 100%;"></textarea>
        </div>

        <div class="modal-footer">
            <button onclick="confirmArrivalRecord()" class="ok-button">記録する</button>
            <button onclick="closeModal('arrivalModal')" class="cancel-button">キャンセル</button>
        </div>
    </div>
</div>
<div id="pinFilterModal" class="modal-overlay">
    <div class="modal-content-box" style="text-align: center; max-width: 500px;">
        <h3>読み込むピンの種類を選択</h3>
        <p>どの種類のピンを地図に表示しますか？</p>
        <div style="display: flex; justify-content: center; gap: 10px; margin: 20px 0;">
            <button class="ok-button" onclick="startPinLoad('全て')">全て</button>
            <button class="ok-button" style="background-color: #007bff;" onclick="startPinLoad('介入のみ')">介入のみ</button>
            <button class="ok-button" style="background-color: #ffc107; color: #212529;" onclick="startPinLoad('非介入のみ')">非介入のみ</button>
        </div>
        <div class="modal-footer">
            <button class="cancel-button" onclick="closeModal('pinFilterModal')">キャンセル</button>
        </div>
    </div>
</div>
</body>
</html>
